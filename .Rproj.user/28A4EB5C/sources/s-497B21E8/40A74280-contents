---
title: "Apatite Data_Plots_v5"
author: "Spencer  Zeigler"
date: "12/14/2020"
output: html_document
editor_options:
  chunk_output_type: console
---

Exploring colors
```{r}
ggthemes::calc_pal()
ggthemes::colorblind_pal()
ggthemes::wsj_pal(palette = "colors6")
ggthemes::palette_pander(7)
jcolors::scale
ggthemes_data$tableau #colorblind #prints hex codes from ggthemes
dichromat::colorschemes

qual_color_random <- c("#322288", "#aa4499", "#44aa99", "#671000", "#989934", "#6599cc", "#aa4466", "#ddcc77", "#000000")
cb <- c("#595959", "#5f9ed1", "#c85200")
cb2 <- c("#f06400", "#949494", "#008CF0")
cb3 <- c("#4ACBFA", "#FAA35E", "#6E61DB")

colorspace::swatchplot(tableau_color_pal("Color Blind"))
colorspace::swatchplot(tf_color)
```

Exploring Ft
```{r}
apatite %>%
  #filter(gc == "C") %>%
  
ggplot(aes(x = s.ft, y = db.ft, color= gc)) + #, key = sample, key2= broken, key3 = notes
  geom_smooth(method= "lm", formula = y~0+x, se=F) +
  geom_point(size = 2) +
  
  labs(title = "Manual 2D vs. Nano-CT 3D Ft", x= "2D Ft", y= "3D Ft") + 
  scale_color_tableau(palette = "Color Blind") +
                      
  geom_abline(slope=1, intercept = 0) + 
  geom_abline(slope=.95, intercept=0, size= .1, linetype= 2) + #5%
  geom_abline(slope=1.05263, intercept=0, size=.1, linetype= 2) + #5%
  geom_abline(slope=.9, intercept=0, size=.1, linetype= 2) + #10%
  geom_abline(slope=1.1111111, intercept=0, size=.1, linetype= 2) + #10%
  geom_abline(slope=.8, intercept=0, size=.1, linetype= 2) + #20%
  geom_abline(slope=1.25, intercept=0, size=.1, linetype= 2)  #20%

#ggplotly(p,  tooltip = c("key", "key2", "key3"))
```

Exploring Volume
```{r}
p <- hex %>%
  
ggplot(aes(x = s.v, y = db.v, color=size.cat)) + # 
  geom_smooth(method= "lm", formula = y~0+x, se = F) +
  geom_point(size = 2) +
  
  labs(title = "Manual 2D vs. Nano-CT 3D Volume", x= "2D Volume", y= "3D Volume") +
  scale_color_manual(values = cb) +
  #xlim(0,750000) + ylim(0, 1000000) +
  geom_abline(slope=1, intercept = 0) + 
  geom_abline(slope=.95, intercept=0, size= .1, linetype= 2) + #5%
  geom_abline(slope=1.05263, intercept=0, size=.1, linetype= 2) + #5%
  geom_abline(slope=.9, intercept=0, size=.1, linetype= 2) + #10%
  geom_abline(slope=1.1111111, intercept=0, size=.1, linetype= 2) + #10%
  geom_abline(slope=.8, intercept=0, size=.1, linetype= 2) + #20%
  geom_abline(slope=1.25, intercept=0, size=.1, linetype= 2) + #20%
  geom_abline(slope=.7, intercept=0, size=.1, linetype= 2) + #30%
  geom_abline(slope=1.42, intercept=0, size=.1, linetype= 2) + #30%
  geom_abline(slope=.6, intercept=0, size=.1, linetype= 2) + #40%
  geom_abline(slope=1.66, intercept=0, size=.1, linetype= 2)  #40%
p
ggplotly(p,  tooltip = c("key", "key2", "key3"))
```

Exploring ESR Ft
```{r}
common_apatite %>%
  filter(gem.geo == "C") %>%
  
  ggplot(mapping=aes(x = s.esr.ft, y = db.esr.ft, color = np)) +
  geom_smooth(method= "lm", formula = y ~ 0 + x, se = FALSE) +
  geom_point(size = 2) +
  labs(title = "Manual 2D vs. Nano-CT 3D ESR Ft", x= "2D ESR Ft", y= "3D ESR Ft") + 
  scale_color_manual(values = cb2) +
  
  geom_abline(slope=1, intercept = 0) + 
  geom_abline(slope=.95, intercept=0, size= .1, linetype= 2) + #5%
  geom_abline(slope=1.05263, intercept=0, size=.1, linetype= 2) + #5%
  geom_abline(slope=.9, intercept=0, size=.1, linetype= 2) + #10%
  geom_abline(slope=1.1111111, intercept=0, size=.1, linetype= 2) + #10%
  geom_abline(slope=.8, intercept=0, size=.1, linetype= 2) + #20%
  geom_abline(slope=1.25, intercept=0, size=.1, linetype= 2)  #20%
```

Did changing all the Np to 2Np chaneg things a lot? Hope not!
```{r}
#Ft
ggplot() + geom_point(apatite, mapping = aes(s.ft.ognp, s.ft, color = np.ognp, key = sample)) + geom_abline(mapping = aes(slope = 1, intercept = 0)) + labs(title = "Ft", x = "OG Np (0,1,2)", y = "2 Np")

#Volume
 ggplot() + geom_point(apatite, mapping = aes(s.v.ognp, s.v, color = np.ognp, key = sample)) + geom_abline(mapping = aes(slope = 1, intercept = 0)) + labs(title = "Volume", x = "OG Np (0,1,2)", y = "2 Np")
#ESR
p <- ggplot() + geom_point(apatite, mapping = aes(s.esr.ft.ognp, s.esr.ft, key = sample)) + geom_abline(mapping = aes(slope = 1, intercept = 0))

ggplotly(p, tooltip = c("key"))
```


############################################################################
Manuscript Draft Figures

1. Plot Results_Figure
```{r}
pvg <- plot.results(apatite, "s.v", "db.v", "geo", "volume") 
pvr <- plot.results(apatite, "s.v", "db.v", "rough", "volume")

psg <- plot.results(apatite, "s.sa", "db.sa", "geo", "surface")
psr <- plot.results(apatite, "s.sa", "db.sa", "rough", "surface")

pftg <- plot.results(apatite, "s.ft", "db.ft", "geo", "ft") 
pftr <- plot.results(apatite, "s.ft", "db.ft", "rough", "ft") 

peg <- plot.results(apatite, "s.esr.ft", "db.esr.ft", "geo", "esr")
per <- plot.results(apatite, "s.esr.ft", "db.esr.ft", "rough", "esr")

figresults <- (pvg | pvr) / (psg | psr) / (pftg + pftr) / (peg + per) 
#save 1100 x 1300

```

2. GEM plot of common grains only with regression slope plotted! 
```{r}
pa1 <- plot.gem(common_apatite, "ft", "bootstrap.common", "A1", "ft")
pb1 <- plot.gem(common_apatite, "ft", "bootstrap.common", "B1", "ft")
pc1 <- plot.gem(common_apatite, "ft", "bootstrap.common", "C1", "ft")
pa2 <- plot.gem(common_apatite, "ft", "bootstrap.common", "A2", "ft")
pb2 <- plot.gem(common_apatite, "ft", "bootstrap.common", "B2", "ft")
pc2 <- plot.gem(common_apatite, "ft", "bootstrap.common", "C2", "ft")
pa3 <- plot.gem(common_apatite, "ft", "bootstrap.common", "A3", "ft")
pb3 <- plot.gem(common_apatite, "ft", "bootstrap.common", "B3", "ft")
pc3 <- plot.gem(common_apatite, "ft", "bootstrap.common", "C3", "ft")
pc3
ft.gem <- (pa1 + pb1 + pc1) / (pa2 + pb2 + pc2) / (pa3 + pb3 + pc3)
ft.gem
```

GEM plot of common grains only with regression slope plotted! 
```{r}
pa1 <- plot.gem(common_apatite, "volume", "bootstrap.common", "A1", "volume")
pb1 <- plot.gem(common_apatite, "volume", "bootstrap.common", "B1", "volume")
pc1 <- plot.gem(common_apatite, "volume", "bootstrap.common", "C1", "volume")
pa2 <- plot.gem(common_apatite, "volume", "bootstrap.common", "A2", "volume")
pb2 <- plot.gem(common_apatite, "volume", "bootstrap.common", "B2", "volume")
pc2 <- plot.gem(common_apatite, "volume", "bootstrap.common", "C2", "volume")
pa3 <- plot.gem(common_apatite, "volume", "bootstrap.common", "A3", "volume")
pb3 <- plot.gem(common_apatite, "volume", "bootstrap.common", "B3", "volume")
pc3 <- plot.gem(common_apatite, "volume", "bootstrap.common", "C3", "volume")

vol.gem <- (pa1 + pb1 + pc1) / (pa2 + pb2 + pc2) / (pa3 + pb3 + pc3)
vol.gem
```

4. Analyzed vs. Observed Distribution 
#Read in number_apatite data for plotting and set columns as factor
```{r}
number_apatite <- read_excel("./Analyzed vs Observed Binned Apatite Data_rmf_v2_jrm_final.xlsx", sheet = "R Cont")
number_apatite <- number_apatite[order(number_apatite$analyzed_width),]
number_apatite<- number_apatite[-c(1079:1102),] #only include grains <200
number_apatite<- number_apatite[-c(1:11),] #only include grains >40


as_tibble(number_apatite)

number_apatite$Bin <- factor(number_apatite$Bin, levels = c("40-50", "51-60", "61-70", "71-80", "81-90", "91-100", "101-110", "111-120", "121-130", "131-140", "141-150", "151-160", "161-170"))

number_apatite$size.name <- factor(number_apatite$size.name, levels=c("Small & Rare", "Small & Common","Typical & Common", "Large & Common", "Large & Rare"))
```

#Plot Analyzed vs. Observed Line Graph
```{r}
theme_set(theme_classic())

ggplot() +
  geom_area(number_apatite, stat="bin", fill="grey90", binwidth=5, mapping= aes(x= analyzed_width)) +
  geom_area(apatite, stat="bin", fill="black", binwidth=5, mapping=aes(x=j.w1)) +
  #scale_x_continuous(breaks= seq(40, 160, 10)) +
  #scale_y_continuous(breaks= seq(0, 120, 30), limits = c(0, 120)) +
  scale_x_continuous(breaks= seq(40, 220, 10)) +
  scale_y_continuous(breaks= seq(0, 120, 30), limits = c(0, 120)) +
  labs(x="Width (µm)", y="Number of Grains")
  #labs(title= "Number of Grains Selected for Nano-CT Analysis as a\nRepresentative Sample of 1100 Apatite Grains Run in the TraIL", x= "Width (µm)", y= "Number of Grains") 
  #theme(axis.text.x = element_text(angle = 60, vjust = 0.99, hjust=1))

```





####################################################################################
Other/Unknown

Examining trends in QQ plots for my data
```{r}
par(mfrow=c(2,2))

mod<- lm(db.ft ~ s.ft, data=df7)
plot(mod)

mod1 <- lm(db.ft ~ s.ft, data= df7.rm)
plot(mod1)

#https://www.ucd.ie/ecomodel/Resources/QQplots_WebVersion.html
```

Notes and old color pals
```{r}
#brp.color <- c("lightseagreen", "firebrick3", "darkorchid3", "#E69F00", "lightseagreen", "firebrick3", "#56B4E9", "#009E73", "#0072B2", "#CC79A7", "#000000")
#bry.color <-c("#2C8C99", "#e5b400","#f44609","#EF476F","#faa612","#550527", "#688d27","#a10702", "#87B38D","#2C666E", "#4D8B31")
#accent.color <- c("#D95F02","cornflowerblue", "darkolivegreen", "darkorchid3")
#brewer.pal(n = 8, name = "Paired") #Pulls a palette from Rcolorbrewer and prints the hex codes

#To use ggsci https://cran.r-project.org/web/packages/ggsci/vignettes/ggsci.html
#scales::viridis_pal()(n=20)
```

Testing how to keep colors the same across plots for samples for morgan
```{r}
#Splits sample col by comma
#df7.sep <- separate(df7, sample, c("samplename", "round", "grain"))
#df7.sep$samplename <- factor(df7.sep$samplename, levels = c("MM", "DCA", "BF16", "16MFS05", "15MFS07", "Bail", "C50", "FCT"))
##Setting my color pallete. The order the colors are in matches the the samples. (ie. MM will be red; DCA will be blue; etc.)
#col.sample <- c("red", "blue", "yellow", "purple", "pink", "green", "orange", "black")

##Plotting my entire dataset
#ggplot(df7.sep, mapping = aes(s.ft, db.ft, color = samplename)) + 
  #scale_color_brewer(palette = "Set1", drop = TRUE,limits = levels(df7.sep$samplename)) +geom_point()

##Creating a new dataset by filtering. New dataset only contains mount 2. 
#df7.sep.mount2 <- df7.sep %>% filter(mount == 2) 

##Plotting mount 2
#p2 <- ggplot(df7.sep.mount2, mapping= aes(s.ft, db.ft, color=samplename)) + 
  #scale_color_brewer(palette = "Set1", drop=TRUE, limits = levels(df7.sep$samplename)) +geom_point()
```

Examining unsurprising trends in ESR I think
```{r}
ggplot() + 
  geom_point(df7, mapping=aes(s.esr.ft, db.esr.ft)) +
  geom_abline(slope=1, intercept=0)

ggplot() + 
  geom_point(df7, mapping=aes(s.rs.trad, db.rs.trad)) +
  geom_abline(slope=1, intercept=0)

ggplot() +
  geom_point(df7, mapping=aes(s.esr.ft, s.rs.trad))
ggplot() + 
  geom_point(df7, mapping=aes(db.esr.ft, db.rs.trad)) 

par(mfrow=c(1,2))

plot(df7$s.esr.ft, df7$s.rs.trad, xlab = "2D ESR Ft", ylab = "2D SA/V Rs")
plot(df7$db.esr.ft, df7$db.rs.trad, xlab = "3D ESR Ft", ylab = "3D SA/V Rs")

```

Ft 238 vs Ft 232
```{r}
ft.df <- read_excel("/Users/spencerzeigler/Documents/Flowers Lab/Apatite Nano-CT Project_Feb 2019_June 2020/Step 8- Statistics/SZ_Ft_Check_04202021.xlsx", sheet = "Ft Check_Final")
na.omit(ft.df)

#ft.df <- ft.df[-688,]
#ft.df <- ft.df[-360,]

p <- ggplot() + 
  geom_point(ft.df, mapping=aes(ft.238, mean.ft, key = sample)) + 
  geom_abline(slope=1, intercept=0) +
  geom_abline(slope=.95, intercept=0, size= .1, linetype= 2) + #5%
  geom_abline(slope=1.05263, intercept=0, size=.1, linetype= 2) + #5%
  geom_abline(slope=.9, intercept=0, size=.1, linetype= 2) + #10%
  geom_abline(slope=1.1111111, intercept=0, size=.1, linetype= 2) + #10%
  geom_abline(slope=.8, intercept=0, size=.1, linetype= 2) + #20%
  geom_abline(slope=1.25, intercept=0, size=.1, linetype= 2) + #20%
  geom_abline(slope=.7, intercept=0, size=.1, linetype= 2) + #30%
  geom_abline(slope=1.42, intercept=0, size=.1, linetype= 2)  #30%

shapiro.test(ft.df$ft.238)
qqline(ft.df$ft.238)

DescTools::SignTest(ft.df$ft.238, ft.df$mean.ft)

wilcox.test(ft.df$ft.238, ft.df$mean.ft) #the two populations are significantly different 
wilcox.test(ft.df$ft238.meanft, mu= 1)
```

#Checking if the regression line through the 238 vs total Ft data is within uncert. of a 1:1 line...it isn't. 
```{r}
x <- ft.df
robust.ft <- lm(mean.ft ~ ft.238, data=x)

sigma.slope.ft <- function(linreg, x) {
fit.ft <- summary(linreg)
fit.ft <- data.frame(fit.ft$coefficients)
df <- data.frame(twoD = x$ft.238,
                 threeD = x$mean.ft, 
                 intercept = rep(fit.ft[1,1], len=nrow(x)), 
                 slope = rep(fit.ft[2,1], len= nrow(x)))
df <- na.omit(df)

delta <- nrow(df) * sum(df$twoD^2) - (sum(df$twoD))^2
sigma.y <- sqrt(1/(nrow(df)-2)*sum((df$threeD - df$intercept - df$twoD*df$slope)^2))
uncert.slope <- sigma.y * sqrt(nrow(df)/delta)
}

sigma.incp.ft <- function(linreg, x) {
fit.ft <- summary(linreg)
fit.ft <- data.frame(fit.ft$coefficients)
df <- data.frame(twoD = x$ft.238,
                 threeD = x$mean.ft, 
                 intercept = rep(fit.ft[1,1], len=nrow(x)), 
                 slope = rep(fit.ft[2,1], len= nrow(x)))
df <- na.omit(df)

delta <- nrow(df) * sum(df$twoD^2) - (sum(df$twoD))^2
sigma.y <- sqrt(1/(nrow(df)-2)*sum((df$threeD - df$intercept - df$twoD*df$slope)^2))
uncert.incept <- sigma.y * sqrt((sum(df$twoD^2))/delta)
}


uncert.slope.ft <- sigma.slope.ft(robust.ft, x)
uncert.incep.ft <- sigma.incp.ft(robust.ft, x)

values <- summary(robust.ft)
stats.df.ft <- rbind(slope=values$coefficients[2,1], sigma.slope = uncert.slope.ft, intercept=values$coefficients[1,1], sigma.intercept = uncert.incep.ft)
stats.df.ft<- as.data.frame(t(as.matrix(stats.df.ft)))

#Slope

        x <- 1
        y <- 1.049366
  u <-  0
  w <-  0.004361325

diff <- x - y
uncert <- sqrt(u^2 + w^2)

if (abs(diff) < abs(uncert)) {
  print("Within 1sigma")
} else {
    print("Not within 1sigma")
}


#INtercept

x <- 0
        y <- 0.049793
  u <-  0
  w <-  0.003101313

diff <- x - y
uncert <- sqrt(u^2 + w^2)

if (abs(diff) < abs(uncert)) {
  print("Within 1sigma")
} else {
    print("Not within 1sigma")
}
```

SA:V Ratios 
```{r}
df7 <- df7 %>%
  dplyr::mutate(db.sav.ratio = 3*db.v/db.sa) %>%
  dplyr::mutate(s.sav.ratio = 3*s.v/s.sa)

ggplot() + 
  #xlim(0.03, .19) + ylim(0.03, .19) +
  geom_point(df7, mapping=aes(s.sav.ratio, db.sav.ratio, color= gc)) +
  geom_abline(slope=1, intercept=0) +
  #labs(title= "SAV.Ratio = SA/V", subtitle= "2D Overestimates SA and V, but 2D Underestimates SAV.Ratio") +
  scale_color_brewer(palette = "Dark2")

#cbpalette <- c("#88e99a", "#2d595a", "#41bbc5", "#5b588f", "#cddb9b")
```

######### Need to be fixed

#Error Bars- Ft
```{r}
quad.df.ft <- read_excel("/Users/spencerzeigler/Documents/Flowers Lab/Apatite Nano-CT Project_Feb 2019_June 2020/Step 8- Statistics/Linear Reg Results.xlsx", sheet= "ft.comp")

quad.df.ft <- quad.df.ft %>%
  select(gem, method.grains, slope, sigma.slope, intercept, sigma.intercept, gem.cat) 
quad.df.ft <- quad.df.ft[order(quad.df.ft$gem),]
quad.df.ft$gem <- factor(quad.df.ft$gem, levels = c("A1", "A2", "A3", "A", "B1", "B2", "B3", "B", "AB", "C1", "C2", "C3", "C"))
quad.df.ft$intercept <- as.numeric(as.character(quad.df.ft$intercept))

pal <- c("grey20", "darkorchid4")
#####################################################################

#Ft error bars, Slope
ggplot(quad.df.ft, aes(x=gem, y=slope, color=method.grains)) + 
   scale_color_nejm(palette="default", 
                    name = "Legend", 
                    labels= c("Intercept Not Fixed", "Intercept Fixed at 0")) +
geom_pointrange(aes(ymin=slope-sigma.slope, ymax=slope+sigma.slope, color= method.grains), alpha= .8) +
  labs(x="GEM", y="Slope")
```

#Error Bars- Volume
```{r}
quad.df.v <- read_excel("/Users/spencerzeigler/Documents/Flowers Lab/Apatite Nano-CT Project_Feb 2019_June 2020/Step 8- Statistics/Linear Reg Results.xlsx", sheet= "vol.reg.master")
quad.df.v <- quad.df.v[c(53:130),]

quad.df.v <- quad.df.v %>%
  select(gem, method.grains, slope, sigma.slope, intercept, sigma.intercept, gem.cat) 
quad.df.v <- quad.df.v[order(quad.df.v$gem),]

quad.df.v$gem <- factor(quad.df.v$gem, levels = c("A1", "A2", "A3", "A", "B1", "B2", "B3", "B", "AB", "C1", "C2", "C3", "C"))
quad.df.v <- quad.df.v %>%
  #filter(!method.grains == "common.only.lm") %>%
  #filter(!method.grains == "common.only.lm.fixed") %>%
  filter(!method.grains == "common.small.rlm") %>%
  filter(!method.grains == "common.large.rlm") %>%
  filter(!method.grains == "common.small.lm") %>%
  filter(!method.grains == "common.large.lm")

#####################################################################

#Volume error bars, Slope
ggplot(quad.df.v, mapping=aes(x=gem, y=slope, color= method.grains)) + 
geom_pointrange(aes(ymin=slope-sigma.slope, ymax=slope+sigma.slope)) +
scale_color_nejm(palette="default") +
labs(title= "1σ Error Bars on Volume Correction Lines for Each GEM", x="GEM", y="Slope")

#Volume error bars, Intercept
ggplot(quad.df.v, aes(x=gem, y=intercept, color= gem.cat)) + 
  scale_color_manual(values=pal, 
                     name="Legend", 
                     labels= c("A & B grains", "C Grains")) +
geom_pointrange(aes(ymin=intercept-sigma.intercept, ymax=intercept+sigma.intercept)) +
  labs(title= "1σ Error Bars on Volume Correction Line Intercepts for Each GEM", subtitle="Calculated with a WLS Linear Regression, Colored by Dataset Regressed", x="GEM", y="Intercept")
```

########## Other Plots

#Heatmap of GEM
```{r}
gemnumber <- read_excel("/Users/spencerzeigler/Documents/Flowers Lab/Apatite Nano-CT Project_Feb 2019_June 2020/Step 8- Statistics/Data Comps_v7.xlsx", sheet="gemnumber")

ggplot(gemnumber, aes(gc, ri, fill=value)) +
  geom_tile() +
   scale_fill_distiller(palette = "RdPu", direction=1) + 
  labs(x= "Geometric Classification", y="Roundness Index") +
  scale_y_reverse() +
  scale_x_discrete(position="top")
```

