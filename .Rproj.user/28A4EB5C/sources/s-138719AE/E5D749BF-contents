---
title: "Apatite Data_Stats_v5"
author: "Spencer  Zeigler"
date: "6/15/2021"
output: html_document
editor_options:
  chunk_output_type: console
---

#Uncertainty Calculations
## Single filter
```{r}
common_apatite %>%
  #filter(gem.geo == "AB") %>%
  bootstrap.linreg("ft")
```

## Double filter 
```{r}
common_apatite %>% 
  filter(gem.geo == "AB") %>% 
  filter(np == "2") %>%
  bootstrap.linreg("esr")
```

#Quadrature
```{r}
#read in spreadsheet of linear regression values
quad <- read_excel("./Linear Reg Results.xlsx", sheet="comp")

#function
error.propagation(quad, "bootstrap.common", "esr", "B", "C")
```

Using bootstrap code to get vectors of slopes to perform t-tests on:
```{r}
    sample_df <- gcb %>% select(sample, s.ft,  db.ft) %>% rename(twoD = s.ft,  threeD = db.ft)
  
  # Set set.seed a starting number to generate a sequence of random numbers so that we can get reproducible results
  set.seed(123)
  #Perform bootstrap 
  sample_boot <- bootstraps(sample_df,
                            times = 1000,
                            apparent = TRUE)
  
  #Run linear regression on each bootstrap
  sample_models <- sample_boot %>% 
    mutate(model = map(splits, ~ lm(twoD ~ 0 + threeD,
                                    data = .) ),
           coef_inf = map(model, tidy))
  #Get coefficients
  sample_coefs <- sample_models %>% 
    unnest(coef_inf)
  

  
  #Get confidence interval 
  percentile_intervals <- int_pctl(sample_models,
                                   coef_inf)
  
  #Store results
  results <<- as.data.frame(cbind(percentile_intervals$.estimate, sd(sample_coefs$estimate),mean(sample_coefs$std.error), (1/percentile_intervals$.estimate))) %>%
    rename(slope = V1, sd = V2, std.error = V3, plot.slope= V4)
  
```

```{r}
lower.ci <- percentile_intervals$.estimate - percentile_intervals$.lower
upper.ci <- percentile_intervals$.upper - percentile_intervals$.estimate 
average.ci <- (lower.ci + upper.ci)/2
```


#Using t test to see if slope values overlap within 1sigma. Same as quadrature. 
```{r}
#Stick this into the bootstrap.linreg code-- unnested. 
  slopes.gcb <- sample_coefs$estimate
  slopes.gca <- sample_coefs$estimate
  slopes.gcc <- sample_coefs$estimate
  
#then do t-tests if you hate urself but you don't need to the results are the same as quadrature. 

t.test(slopes.gca, slopes.gcb)

gca.2.5 <- quantile(slopes.gca, .025)
gca.97.5 <- quantile(slopes.gca,.975)

gcc.2.5 <- quantile(slopes.gcc, .025)
gcc.97.5 <-  quantile(slopes.gcc, .975)

gcb.2.5 <- quantile(slopes.gcb, .025)
gcb.97.5 <-  quantile(slopes.gcb, .975)

```

Average % error
```{r}
percent.diff <- function(df) {
   ftd <- round(mean(abs(df$s.ft - df$db.ft)/((df$s.ft + df$db.ft)/2) * 100),2)
   fts <- round(2*sd(abs(df$s.ft - df$db.ft)/((df$s.ft + df$db.ft)/2) * 100),2)
 
    vd <- round(mean(abs(df$s.v - df$db.v)/((df$s.v + df$db.v)/2) * 100),2)
    vs <- round(2*sd(abs(df$s.v - df$db.v)/((df$s.v + df$db.v)/2) * 100),2)
  
    sad <- round(mean(abs(df$s.sa - df$db.sa)/((df$s.sa + df$db.sa)/2) * 100), 2)
    sas <- round(2*sd(abs(df$s.sa - df$db.sa)/((df$s.sa + df$db.sa)/2) * 100),2)
    esrd <- round(mean(abs(df$s.esr.ft - df$db.esr.ft)/((df$s.esr.ft + df$db.esr.ft)/2) * 100), 2)
    esrs <- round(2*sd(abs(df$s.esr.ft - df$db.esr.ft)/((df$s.esr.ft + df$db.esr.ft)/2) * 100),2)
  
    abs.diff <- c(ftd, vd, sad, esrd)
    twosigma <- c(fts, vs, sas, esrs)
    
return(data.frame(abs.diff, twosigma, row.names = c("ft", "vol", "sa", "esr")))
}

ri12 <- apatite %>% filter(ri == "1" | ri == "2")

percent.diff(apatite)
percent.diff(gcc)
percent.diff(ab)
percent.diff(ri12)
percent.diff(ri3)

```

#Sampling a subset of the data (without replacement)
```{r}
#Sample size should be ~10% of population 

unique2d <- matrix(nrow = 20, ncol = 1000)
unique3d <- matrix(nrow = 20, ncol = 1000)
uniqueslopes <- list()


for (i in 1:1000) {
  unique2d[,i] <- sample(common_apatite$s.ft, size=20, replace = F)
  unique3d[,i] <- sample(common_apatite$db.ft, size=20, replace = F)
  uniqueslopes[i] <- summary(lm(unique2d[,i] ~ 0 + unique3d[,i]))$coefficients[[1]]
}

uniqueslopes <- unlist(uniqueslopes) 
uniqueslopes <- as.data.frame(uniqueslopes)

unique2d <- as.data.frame(unique2d) %>%
  rename(simulated1 = V1, simulated2 = V2, simulated3 = V3, simulated4= V4)
unique2d <- unique2d %>% pivot_longer(cols = 1:4)

ggplot() + 
  geom_histogram(uniqueslopes, mapping = aes(x = uniqueslopes), fill = "white", color = "black") +
  labs(title = "Slopes calculated from 1000 samples of n= 20 (without replacement)", x = "Slopes") +
  geom_vline(xintercept = mean(uniqueslopes$uniqueslopes), color = "blue", size =1.5) +
  annotate("text", x = 1.045, y = 95, label = glue("mean = {round(mean(uniqueslopes$uniqueslopes),3)}"), size = 5)

sd(uniqueslopes$uniqueslopes)

ggplot() + 
  geom_histogram(unique2d, mapping=aes(x=value)) +
  facet_wrap(~name) +
  xlab("2D Ft") 

ggplot() + 
  geom_histogram(common_apatite, mapping=aes(x=s.ft)) 
```

#Sampling with replacement
```{r}
replaced2d <- matrix(nrow = 200, ncol = 1000)
replaced3d <- matrix(nrow = 200, ncol = 1000)
replacedslopes <- list()
for (i in 1:1000) {
  replaced2d[,i] <- sample(common_apatite$s.ft, size=200, replace = T)
  replaced3d[,i] <- sample(common_apatite$db.ft, size=200, replace = T)
  replacedslopes[i] <- summary(lm(replaced2d[,i] ~ 0 + replaced3d[,i]))$coefficients[[1]]
}
replacedslopes <- unlist(replacedslopes) 
replacedslopes <- as.data.frame(replacedslopes)

replaced2d <- as.data.frame(replaced2d) %>%
  rename(simulated1 = V1, simulated2 = V2, simulated3 = V3, simulated4= V4)
replaced2d <- replaced2d %>% pivot_longer(cols = 1:4)

ggplot() + 
  geom_histogram(replacedslopes, mapping = aes(x = replacedslopes), fill = "white", color = "black") +
  labs(title = "Slopes calculated from 1000 samples of n= 200 (with replacement)", x = "Slopes") +
  geom_vline(xintercept = mean(replacedslopes$replacedslopes), color = "red", size =1.5) +
  annotate("text", x = 1.035, y = 90, label = glue("mean = {round(mean(replacedslopes$replacedslopes),3)}"), size = 5)

sd(replacedslopes$replacedslopes)


mean(replacedslopes$replacedslopes)
ggplot() + 
  geom_histogram(replaced2d, mapping=aes(x=value)) +
  facet_wrap(~name) + xlab("2D Ft")


ggplot() + 
  geom_histogram(replaced2d, mapping=aes(x= replaced2d))




```

```{r}
reg.conf.intervals <- function(x, y) {
  n <- length(y) # Find length of y to use as sample size
  lm.model <- lm(y ~ x) # Fit linear model
  
  # Extract fitted coefficients from model object
  b0 <- lm.model$coefficients[1]
  b1 <- lm.model$coefficients[2]
  
  # Find SSE and MSE
  sse <- sum((y - lm.model$fitted.values)^2)
  mse <- sse / (n - 2)
  
  t.val <- qt(0.975, n - 2) # Calculate critical t-value
  
  # Fit linear model with extracted coefficients
  x_new <- 1:max(x)
  y.fit <- b1 * x_new + b0
  
  # Find the standard error of the regression line
  se <- sqrt(sum((y - y.fit)^2) / (n - 2)) * sqrt(1 / n + (x - mean(x))^2 / sum((x - mean(x))^2))
  
  # Fit a new linear model that extends past the given data points (for plotting)
  x_new2 <- 1:max(x + 100)
  y.fit2 <- b1 * x_new2 + b0
  
  # Warnings of mismatched lengths are suppressed
  slope.upper <- suppressWarnings(y.fit2 + t.val * se)
  slope.lower <- suppressWarnings(y.fit2 - t.val * se)
  
  # Collect the computed confidence bands into a data.frame and name the colums
  bands <- data.frame(cbind(slope.lower, slope.upper))
  colnames(bands) <- c('Lower Confidence Band', 'Upper Confidence Band')
  
  # Plot the fitted linear regression line and the computed confidence bands
  plot(x, y, cex = 1.75, pch = 21, bg = 'gray')
  lines(y.fit2, col = 'black', lwd = 2)
  lines(bands[1], col = 'blue', lty = 2, lwd = 2)
  lines(bands[2], col = 'blue', lty = 2, lwd = 2)
  
  return(bands)
}
par(mfrow=c(1,1))
reg.conf.intervals(common_apatite$db.ft, common_apatite$s.ft)
```


##Resources:

* [Bootstrapping Code](https://towardsdatascience.com/bootstrap-sampling-in-r-a7bc9d3ca14a)
* [Confidence Intervals vs Std Deviation](https://stats.stackexchange.com/questions/151541/confidence-intervals-vs-standard-deviation/377634#:~:text=standard%20deviation,-confidence%2Dinterval%20standard&text=The%2095%25%20confidence%20interval%20gives,a%20range%20of%20~95%25.)
* [Overlapping Confidence Intervals](https://towardsdatascience.com/tutorial-for-using-confidence-intervals-bootstrapping-860ba716aef3)




##DEAD TO MEEEE

Playing around with glance, lm. 
```{r}
test <- apatite %>% nest(data = -c(s.gem, gc, np))
test <- apatite %>% nest(data = -s.gem) %>% mutate(fit = map(data, ~lm(s.ft ~ 0 + db.ft, data=.x))) 

lmresults <- test %>% 
  mutate(s = map(fit, summary)) %>% 
  mutate(glance_out = map(s, tidy)) %>%
  select(s.gem, glance_out) %>%
  unnest(glance_out)

```

#Quadrature for volume
```{r}
quad.df.v <- read_excel("/Users/spencerzeigler/Documents/Flowers Lab/Apatite Nano-CT Project_Feb 2019_June 2020/Step 8- Statistics/Linear Reg Results.xlsx", sheet= "vol.reg.master")
quad.df.v <- quad.df.v[c(53:130),]

quad.df.v <- quad.df.v %>%
  select(gem, method.grains, slope, sigma.slope, intercept, sigma.intercept) 
quad.df.v <- quad.df.v[order(quad.df.v$gem),]

        x <- quad.df.v$intercept[19]
        y <- quad.df.v$intercept[20]
  u <- quad.df.v$sigma.intercept[19]
  w <- quad.df.v$sigma.intercept[20]

diff <- x - y
uncert <- sqrt(u^2 + w^2)

if (abs(diff) < abs(uncert)) {
  print("Within 1sigma")
} else {
    print("Not within 1sigma")
}
```

#Quadrature for Ft v2-- using ft.comp
```{r}
quad.df.ft <- read_excel("/Users/spencerzeigler/Documents/Flowers Lab/Apatite Nano-CT Project_Feb 2019_June 2020/Step 8- Statistics/Linear Reg Results.xlsx", sheet= "ft.comp")

quad.df.ft <- quad.df.ft %>%
  select(gem, method.grains, slope, sigma.slope, intercept, sigma.intercept) 
quad.df.ft <- quad.df.ft[order(quad.df.ft$gem),]

        x <- quad.df.ft$slope[7]
        y <- quad.df.ft$slope[8]
  u <- quad.df.ft$sigma.slope[7]
  w <- quad.df.ft$sigma.slope[8]

diff <- x - y
uncert <- sqrt(u^2 + w^2)

if (abs(diff) < abs(uncert)) {
  print("Within 1sigma")
} else {
    print("Not within 1sigma")
}
```


####Dead to me
```{r}
#SLOPE UNCERT, INTERCEPT=0, VOLUME
sigma.slope.v.fixed.incp <- function(linreg, x) {
fit.v <- summary(linreg)
fit.v <- data.frame(fit.v$coefficients)
df <- data.frame(twoD = x$s.v,
                 threeD = x$db.v, 
                 slope = rep(fit.v[1,1], len= nrow(x)))

delta <- nrow(df) * sum(df$twoD^2) - (sum(df$twoD))^2
sigma.y <- sqrt(1/(nrow(df)-2)*sum((df$threeD - 0 - df$twoD*df$slope)^2))
uncert.slope <- sigma.y * sqrt(nrow(df)/delta)
}


#SLOPE UNCERT, INTERCEPT /=/ 0, FT
sigma.slope.ft <- function(linreg, x) {
fit.ft <- summary(linreg)
fit.ft <- data.frame(fit.ft$coefficients)
df <- data.frame(twoD = x$s.ft,
                 threeD = x$db.ft, 
                 intercept = rep(fit.ft[1,1], len=nrow(x)), 
                 slope = rep(fit.ft[2,1], len= nrow(x)))

delta <- nrow(df) * sum(df$twoD^2) - (sum(df$twoD))^2
sigma.y <- sqrt(1/(nrow(df)-2)*sum((df$threeD - df$intercept - df$twoD*df$slope)^2))
uncert.slope <- sigma.y * sqrt(nrow(df)/delta)
}
#INTERCEPT UNCERT, INTERCEPT /=/ 0, FT
sigma.incp.ft <- function(linreg, x) {
fit.ft <- summary(linreg)
fit.ft <- data.frame(fit.ft$coefficients)
df <- data.frame(twoD = x$s.ft,
                 threeD = x$db.ft, 
                 intercept = rep(fit.ft[1,1], len=nrow(x)), 
                 slope = rep(fit.ft[2,1], len= nrow(x)))
delta <- nrow(df) * sum(df$twoD^2) - (sum(df$twoD))^2
sigma.y <- sqrt(1/(nrow(df)-2)*sum((df$threeD - df$intercept - df$twoD*df$slope)^2))
uncert.incept <- sigma.y * sqrt((sum(df$twoD^2))/delta)
}


#SLOPE UNCERT, INTERCEPT /=/ -, VOLUME
sigma.slope.v <- function(linreg, x) {
fit.v <- summary(linreg)
fit.v <- data.frame(fit.v$coefficients)
df <- data.frame(twoD = x$s.v,
                 threeD = x$db.v, 
                 intercept = rep(fit.v[1,1], len=nrow(x)), 
                 slope = rep(fit.v[2,1], len= nrow(x)))

delta <- nrow(df) * sum(df$twoD^2) - (sum(df$twoD))^2
sigma.y <- sqrt(1/(nrow(df)-2)*sum((df$threeD - df$intercept - df$twoD*df$slope)^2))
uncert.slope <- sigma.y * sqrt(nrow(df)/delta)
}
#INTERCEPT UNCERT, INTERCEPT /=/ 0, VOLUME
sigma.incp.v <- function(linreg, x) {
fit.v <- summary(linreg)
fit.v <- data.frame(fit.v$coefficients)
df <- data.frame(twoD = x$s.v,
                 threeD = x$db.v, 
                 intercept = rep(fit.v[1,1], len=nrow(x)), 
                 slope = rep(fit.v[2,1], len= nrow(x)))

delta <- nrow(df) * sum(df$twoD^2) - (sum(df$twoD))^2
sigma.y <- sqrt(1/(nrow(df)-2)*sum((df$threeD - df$intercept - df$twoD*df$slope)^2))
uncert.incept <- sigma.y * sqrt((sum(df$twoD^2))/delta)
}


#Function that produces the normalized residual standard error [must run code chunk that adds residual values to dataframe]
norm.rse <- function(n.resid, n) {
  sqrt((sum((n.resid)^2)/(n-2)))
}

#Function that produces the normalized residual standard error [must run code chunk that adds residual values to dataframe]
norm.rse <- function(n.resid, n) {
  sqrt((sum((n.resid)^2)/(n-2)))
}


```


#Stats Data for A & B- Ft
```{r}
x <- 
robust.ft <- lm(db.ft ~ s.ft, data=x)

#Append Residuals to Dataframes & Calculated Norm. Residual Std Error 
df.ft.resid <- x %>%
  mutate(s.ft.resid = resid(robust.ft)) %>%
  mutate(s.ft.resid.norm = s.ft.resid/db.ft) %>%
  mutate(s.ft.resid.norm.percent = s.ft.resid.norm*100)
n.resid <- df.ft.resid$s.ft.resid.norm
n <- nrow(df.ft.resid)

norm <- norm.rse(n.resid, n)

#For A & B GEM-- formatted for "normal" slope + intercept data
uncert.slope.ft <- sigma.slope.ft(robust.ft, x)
uncert.incep.ft <- sigma.incp.ft(robust.ft, x)


#Create dataframe with values I need
values <- summary(robust.ft)
stats.df.ft <- rbind(slope=values$coefficients[2,1], sigma.slope = uncert.slope.ft, intercept=values$coefficients[1,1], sigma.intercept = uncert.incep.ft, norm.std.error=norm, std.error=values$sigma)
stats.df.ft<- as.data.frame(t(as.matrix(stats.df.ft)))
```

#Stats Data for Fixed Intercept- Ft
```{r}
x <- 
robust.zero.ft <- lm(db.ft ~ 0 + s.ft, data=x)

#Append Residuals to Dataframes & Calculated Norm. Residual Std Error 
y<- resid(robust.zero.ft, na.action = na.exclude)

df.ft.resid <- x %>%
  mutate(s.ft.resid = y) %>%
  mutate(s.ft.resid.norm = s.ft.resid/db.ft) %>%
  mutate(s.ft.resid.norm.percent = s.ft.resid.norm*100)
n.resid <- df.ft.resid$s.ft.resid.norm
n <- nrow(df.ft.resid)

norm <- norm.rse(n.resid, n)

#Uncertainty in slope and intercept
uncert.slope.ft <- slope.uncertainty.ft(robust.zero.ft, x)

#Create dataframe with values I need
values <- summary(robust.zero.ft)
stats.df.ft <- rbind(slope=values$coefficients[1,1], sigma.slope = uncert.slope.ft, intercept=0, sigma.intercept = 0, norm.std.error=norm, std.error=values$sigma)
stats.df.ft <- as.data.frame(t(as.matrix(stats.df.ft)))
```

#Stats Data for A & B- Volume
```{r}
x <- df.ab
robust.v <- lm(db.v ~ s.v, data=x)

#Append Residuals to Dataframes & Calculated Norm. Residual Std Error 
df.v.resid <- x %>%
  mutate(s.v.resid = resid(robust.v)) %>%
  mutate(s.v.resid.norm = s.v.resid/db.v) %>%
  mutate(s.v.resid.norm.percent = s.v.resid.norm *100) 

n.resid <- df.v.resid$s.v.resid.norm
n <- nrow(df.v.resid)

norm <- norm.rse(n.resid, n)

#For A & B GEM-- formatted for "normal" slope + intercept data
uncert.slope.v <- sigma.slope.v(robust.v, x)
uncert.incep.v <- sigma.incp.v(robust.v, x)

#Create dataframe with values I need
values <- summary(robust.v)
stats.df.v <- rbind(slope=values$coefficients[2,1], sigma.slope = uncert.slope.v, intercept=values$coefficients[1,1], sigma.intercept = uncert.incep.v, norm.std.error=norm, std.error=values$sigma)
stats.df.v<- as.data.frame(t(as.matrix(stats.df.v)))
```

#Stats Data for C - Volume
```{r}
x <- df.c3
robust.zero.v <- lm(db.v ~ 0 + s.v, data=x)

#Append Residuals to Dataframes & Calculated Norm. Residual Std Error 
df.v.resid <- x %>%
  mutate(s.v.resid = resid(robust.zero.v)) %>%
  mutate(s.v.resid.norm = s.v.resid/db.v) %>%
  mutate(s.v.resid.norm.percent = s.v.resid.norm *100) 

n.resid <- df.v.resid$s.v.resid.norm
n <- nrow(df.v.resid)

norm <- norm.rse(n.resid, n)

#For A & B GEM-- formatted for "normal" slope + intercept data
uncert.slope.v <- sigma.slope.v.fixed.incp(robust.zero.v, x)

#Create dataframe with values I need
values <- summary(robust.zero.v)
stats.df.v <- rbind(slope=values$coefficients[1,1], sigma.slope = uncert.slope.v, intercept=0, sigma.intercept = 0, norm.std.error=norm, std.error=values$sigma)
stats.df.v<- as.data.frame(t(as.matrix(stats.df.v)))
```


Nested equivilent of tidymodels bootstrap
```{r}
sample_df_nested <- common_apatite %>% 
      select(sample, s.gem, s.ft,  db.ft) %>% 
      rename(twoD = s.ft,  threeD = db.ft) %>%
      nest(data= -s.gem)
  
  set.seed(123)
  #Perform bootstrap 
  nested_boot <- bootstraps(sample_df_nested,
                            times = 1000,
                            apparent = TRUE)
  nested_split <- nested_boot$splits
  
  #Run linear regression on each bootstrap
  for (i in 1:1001) {r
    sample_models_nested <- map(nested_split[[i]]$data[[2]], ~ lm(twoD ~ 0 + threeD, data = .))
  }

#Get coefficients
sample_coefs_nested <- map(sample_models_nested, ~ tidy(.x))
sample_coefs_nested <- do.call(rbind.data.frame, sample_coefs_nested)
sample_coefs_nested <- cbind(c("A1", "A2", "A3", "B1", "B2", "B3", "C1", "C2", "C3"), sample_coefs_nested)%>% rename(gem =  'c("A1", "A2", "A3", "B1", "B2", "B3", "C1", "C2", "C3")')
```

Unnested equivilent of tidymodels bootstrap-- to play around with.
```{r}
sample_df <- apatite %>% 
      select(sample, s.gem, s.ft,  db.ft) %>% 
      rename(twoD = s.ft,  threeD = db.ft) 
  
  set.seed(123)
  #Perform bootstrap 
  sample_boot <- bootstraps(sample_df,
                            times = 1000,
                            apparent = F)
  
  hist(apatite$s.ft)
  hist(sample_boot$splits[[100]][[1]][[3]])
  hist(apatite$db.ft)
  
  hist(sample_boot$splits[[100]][[1]][[4]])

  bootstraps(mtcars, times = 2)
  
  
  #Run linear regression on each bootstrap
  sample_models <- sample_boot %>% 
    mutate(model = map(splits, ~ lm(twoD ~ 0 + threeD,
                                    data = .) ),
           coef_inf = map(model, tidy))
  
  #Get coefficients
  sample_coefs <- sample_models %>% 
    unnest(coef_inf)
  
  #Get confidence interval 
  percentile_intervals <- int_pctl(sample_models,
                                   coef_inf)
  
  #Store results
  results <<- as.data.frame(cbind(percentile_intervals$.estimate, sd(sample_coefs$estimate),mean(sample_coefs$std.error), (1/percentile_intervals$.estimate))) %>%
    rename(slope = V1, sd = V2, std.error = V3, plot.slope= V4 )
  
  print(results)
```

```{r}
manualboot_subset <- sample(common_apatite$s.ft, 100, replace = F) 
hist(manualboot)
hist(common_apatite$s.ft)
hist(manualboot_subset)

manualboot_subset <- sample(common_apatite$s.ft, 100, replace = F) 

```


