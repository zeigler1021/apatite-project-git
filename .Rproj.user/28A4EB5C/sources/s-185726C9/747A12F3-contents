---
title: "Apatite Data_Loading and Setup"
author: "Spencer  Zeigler"
date: "6/16/2021"
output:
  html_document: 
    df_print: paged
    css: stylesheet.css
    number_sections: yes
    toc: yes
    toc_float: true
    toc_depth: 3
    code_folding: show
editor_options:
  chunk_output_type: console
---

#Setup
```{r setup, include=FALSE}
#for stats
options(java.parameters = "-Xmx8000m") #to prevent Java heap space error. set to full RAM of tthis computer (8gB) 
#https://stackoverflow.com/questions/21937640/handling-java-lang-outofmemoryerror-when-writing-to-excel-from-r
library(rJava) 
library(MASS) 
library(performance) #check model
library(tidymodels)
library(tictoc) #check how long model takes to run


#tidyverse
library(tidyverse) #purr, dplyr, tidyr, readr, readxl, tibble, stringr, forcats, ggplot2
library(broom)
library(scales) 
library(readxl) 
library(glue)

#for viz
library(plotly)
library(patchwork)
library(RColorBrewer)
library(colorspace)
library(jcolors)
library(viridis)
library(ggsci)
library(ggthemes)

#for knitting
library(knitr)
library(tinytex)
library(latex2exp) 

#library(xlsx) 
#library(datapaste)

par(mfrow=c(1, 1)) #how to arrange plots, 1 per row, 1 per column

#Theme options
theme_set(theme_light())
theme_update(plot.title = element_text(hjust = 0.5)) #adjusts theme so that all titles are centered
theme_update(plot.subtitle= element_text(hjust = 0.5)) #adjusts subtitle so they are all centered
#options(scipen = -1) #prints numbers instead of scientific notation
```

# Color palettes 
```{r}
qual_color_random <- c("#322288", "#aa4499", "#44aa99", "#671000", "#989934", "#6599cc", "#aa4466", "#ddcc77", "#000000")
cb <- c("#595959", "#5f9ed1", "#c85200")
cb2 <- c("#f06400", "#949494", "#008CF0")
tf_color <- c("#ed6a5e", "#9ebc9e", "#553e4e")

```

# Import Data
Import master datasheet
```{r}
apatite <- read_excel("./Data Comps_Final.xlsx", sheet="Data Comps") 
as_tibble(apatite)
```

#Create volume (mm) and (Rs)
```{r}
# apatite <- apatite %>%
#   mutate(s.v.mm = s.v/1000) %>%
#   mutate(db.v.mm = db.v/1000)

# apatite <- apatite %>%
#   mutate(s.v.rs = ((3*s.v)/(4*pi))^(1/3)) %>%
#   mutate(db.v.rs = ((3*db.v)/(4*pi))^(1/3))

```

Setting cols as factor for plotting
```{r}
apatite$size.bin <- factor(apatite$size.bin, levels = c("40-50", "51-60", "61-70", "71-80", "81-90", "91-100", "101-110", "111-120", "121-130", "131-140", "141-150", "151-160", "161-170"))

apatite$gem <- factor(apatite$gem, levels = c("A1", "A2", "B1", "B2", "C1", "C2"))

apatite$gc <- factor(apatite$gc, levels = c("A", "B", "C"))
apatite$ri <- factor(apatite$ri, levels = c("1", "2"))

apatite$size.name <- factor(apatite$size.name, levels=c("Small & Rare","Small & Common","Typical & Common", "Large & Common", "Large & Rare"))

apatite$size.cat <- factor(apatite$size.cat, levels = c("rare- small", "common",  "rare- large"))

apatite$np <- factor(apatite$np, levels= c("term0", "term1", "term2"))

groupings <- as.vector(c("A", "A1", "A2", "B", "B1", "B2", "C", "C1", "C2", "hexagonal", "ellipsoid", "1", "2", "term0", "term1", "term2", "rare- small", "common", "rare- large"), mode = "character")

```

Import Linear Regression Data
```{r}
#get vector of sheet names
sheet_names <- excel_sheets("./Regression Results_Final.xlsx")
#import all sheets into a list
linreg_results <- lapply(sheet_names, function(x) read_excel(path = "./Regression Results_Final.xlsx", sheet = x))
#export each element of list as a dataframe
for (i in 1:20) {
  assign(paste(sheet_names[[i]]), linreg_results[[i]])
}
```

Making dataframe of 'common only' apatite
```{r}
#Grains Removed
#common_apatite <- apatite %>%
  #filter(!size.name == "Large & Rare", !size.name == "Small & Rare")
```

Making parameter based dataframes
```{r}
#Dataframe by Roughness Index 
ri1 <- apatite %>% filter(ri=="1")
ri2 <- apatite %>% filter(ri=="2")
#ri3 <- apatite %>% filter(ri=="3")

#Dataframe by Geometric Classification
a <- apatite %>% filter(gc=="A") 
b <- apatite %>% filter(gc=="B") 
c <- apatite %>% filter(gc=="C") 
ab <- apatite %>% filter(gc == "A" | gc == "B") %>% mutate(gem= "AB")

#Create Dataframes split by both geometry and roughness 
a1 <- apatite %>% filter(gem == "A1") 
a2 <- apatite %>% filter(gem == "A2")
# a3 <- apatite %>% filter(s.gem == "A3")
b1 <- apatite %>% filter(gem == "B1") 
b2 <- apatite %>% filter(gem == "B2")
# b3 <- apatite %>% filter(s.gem == "B3")
c1 <- apatite %>% filter(gem == "C1") 
c2 <- apatite %>% filter(gem == "C2")
# c3 <- apatite %>% filter(s.gem == "C3")

#Make dataframes based on terminations 
term0 <- apatite %>% filter(np == "term0")
term1 <- apatite %>% filter(np == "term1")
term2 <- apatite %>% filter(np == "term2")
```

#Load functions

Statistics functions
```{r}
source("./Functions/function_error_propagation.R")
#source("function_bootstrapped_slopes.R")
#source("function_linreg_slope_uncertainty.R")
source("./Functions/function_model_diagnostics.R")
#source("function_ttest_compare.R")
source("./Functions/function_bootstrap_linreg_nested.R")
source("./Functions/function_taylor_uncertainties_nested.R")
source("./Functions/function_taylor_uncertainties_nested_notfixed.R")
source("./Functions/function_bootstrap_linreg_nested_notfixed.R")
```

Plotting functions
```{r}
#source("function_error_lines.R")
#source("function_plot_results.R")
```






