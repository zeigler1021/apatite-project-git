---
title: "Apatite Data_Stats_v5"
author: "Spencer  Zeigler"
date: "11/24/2020"
output:
  html_document: 
    df_print: paged
    css: stylesheet.css
    number_sections: yes
    toc: yes
    toc_float: true
    toc_depth: 3
    code_folding: show
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
# load libraries

library(MASS) 
library(latex2exp) 
library(readxl) 
library(ggplot2)
library(tidyverse) 
library(tidyr) 
library(scales) 
library(dplyr) 
library(readr) 
library(xlsx) 
library(performance) #check model

par(mfrow=c(1, 1)) #how to arrange plots, 1 per row, 1 per column

#Theme options
theme_set(theme_linedraw())
theme_update(plot.title = element_text(hjust = 0.5)) #adjusts theme so that all titles are centered
theme_update(plot.subtitle= element_text(hjust = 0.5)) #adjusts subtitle so they are all centered
options(scipen = 999) #prints numbers instead of scientific notation
```

#Import Data
```{r}
apatite <- read_excel("/Users/spencerzeigler/Documents/Flowers Lab/Apatite Nano-CT Project_Feb 2019_June 2020/Step 8- Statistics/Data Comps_v7.xlsx", sheet="Data Comps") #This loads data from a .xlsx. Must name the sheet if there are multiple sheets. 
as_tibble(apatite)

apatite <- apatite %>%
  filter(!is.na(apatite$empty)) #this gets rid of data points that are missing information
```

Creating Dataframes 
```{r}
#Grains Removed
common_apatite <- apatite %>%
  filter(!size.name == "Large & Rare", !size.name == "Small & Rare")

#Dataframe by Roughness Index 
ri1 <- common_apatite %>% filter(ri=="1")
ri2 <- common_apatite %>% filter(ri=="2")
ri3 <- common_apatite %>% filter(ri=="3")

#Dataframe by Geometric Classification
gca <- common_apatite %>% filter(gc=="A") 
gcb <- common_apatite %>% filter(gc=="B") 
gcc <- common_apatite %>% filter(gc=="C") 
ab <- common_apatite %>% filter(gc == "A" | gc == "B") %>% mutate(s.gem= "AB")

#Create Dataframes split by both geometry and roughness 
a1 <- common_apatite %>% filter(s.gem == "A1") 
a2 <- common_apatite %>% filter(s.gem == "A2")
a3 <- common_apatite %>% filter(s.gem == "A3")
b1 <- common_apatite %>% filter(s.gem == "B1") 
b2 <- common_apatite %>% filter(s.gem == "B2")
b3 <- common_apatite %>% filter(s.gem == "B3")
c1 <- common_apatite %>% filter(s.gem == "C1") 
c2 <- common_apatite %>% filter(s.gem == "C2")
c3 <- common_apatite %>% filter(s.gem == "C3")

#Make dataframes based on terminations 
term0 <- common_apatite %>% filter(np == "0")
term1 <- common_apatite %>% filter(np == "1")
term2 <- common_apatite %>% filter(np =="2")
```

#Function to print the uncertianty on the slope of the linear regression
```{r}
slope.uncertainty <- function(df, param) {

if (param == "ft") {
  y <- df$db.ft
  x <- df$s.ft
  fit <- summary(lm(y ~ 0 + x, data= df))
  std_err <- fit$sigma
  fit <- data.frame(fit$coefficients)
  df_values <- data.frame(twoD = df$s.ft,
                 threeD = df$db.ft, 
                 slope = rep(fit[1,1], len= nrow(df))) 
  
  delta <- nrow(df_values) * sum(df_values$twoD^2) - (sum(df_values$twoD))^2
  sigma.y <- sqrt(1/(nrow(df_values)-2)*sum((df_values$threeD - 0 - df_values$twoD*df_values$slope)^2))
  
  uncert.slope <- sigma.y * sqrt(nrow(df_values)/delta)
  
  results <- rbind(slope=fit[1,1], sigma.slope=uncert.slope, intercept=0, sigma.intercept=0, std.error=std_err)
  results <<- as.data.frame(t(as.matrix(results)))
  }

if (param == "volume") {
  y <- df$db.v
  x <- df$s.v
  fit <- summary(lm(y ~ 0 + x, data= df))
  std_err <- fit$sigma
  fit <- data.frame(fit$coefficients)
  df_values <- data.frame(twoD = df$s.v,
                   threeD = df$db.v, 
                   slope = rep(fit[1,1], len= nrow(df)))
  
  delta <- nrow(df_values) * sum(df_values$twoD^2) - (sum(df_values$twoD))^2
  sigma.y <- sqrt(1/(nrow(df_values)-2)*sum((df_values$threeD - 0 - df_values$twoD*df_values$slope)^2))
  
  uncert.slope <- sigma.y * sqrt(nrow(df_values)/delta)

  results <- rbind(slope=fit[1,1], sigma.slope=uncert.slope, intercept=0, sigma.intercept=0, std.error=std_err)
  results <<- as.data.frame(t(as.matrix(results)))
  }
}
```

#Quadrature
```{r}
#read in spreadsheet of linear regression values
quad <- read_excel("./Linear Reg Results.xlsx", sheet="comp")

#function
error.propagation(quad, "common.only.lm.fixed", "ft", "A", "C")

```









##DEAD TO MEEEE

#Quadrature for volume
```{r}
quad.df.v <- read_excel("/Users/spencerzeigler/Documents/Flowers Lab/Apatite Nano-CT Project_Feb 2019_June 2020/Step 8- Statistics/Linear Reg Results.xlsx", sheet= "vol.reg.master")
quad.df.v <- quad.df.v[c(53:130),]

quad.df.v <- quad.df.v %>%
  select(gem, method.grains, slope, sigma.slope, intercept, sigma.intercept) 
quad.df.v <- quad.df.v[order(quad.df.v$gem),]

        x <- quad.df.v$intercept[19]
        y <- quad.df.v$intercept[20]
  u <- quad.df.v$sigma.intercept[19]
  w <- quad.df.v$sigma.intercept[20]

diff <- x - y
uncert <- sqrt(u^2 + w^2)

if (abs(diff) < abs(uncert)) {
  print("Within 1sigma")
} else {
    print("Not within 1sigma")
}
```

#Quadrature for Ft v2-- using ft.comp
```{r}
quad.df.ft <- read_excel("/Users/spencerzeigler/Documents/Flowers Lab/Apatite Nano-CT Project_Feb 2019_June 2020/Step 8- Statistics/Linear Reg Results.xlsx", sheet= "ft.comp")

quad.df.ft <- quad.df.ft %>%
  select(gem, method.grains, slope, sigma.slope, intercept, sigma.intercept) 
quad.df.ft <- quad.df.ft[order(quad.df.ft$gem),]

        x <- quad.df.ft$slope[7]
        y <- quad.df.ft$slope[8]
  u <- quad.df.ft$sigma.slope[7]
  w <- quad.df.ft$sigma.slope[8]

diff <- x - y
uncert <- sqrt(u^2 + w^2)

if (abs(diff) < abs(uncert)) {
  print("Within 1sigma")
} else {
    print("Not within 1sigma")
}
```


####Dead to me
```{r}
#SLOPE UNCERT, INTERCEPT=0, VOLUME
sigma.slope.v.fixed.incp <- function(linreg, x) {
fit.v <- summary(linreg)
fit.v <- data.frame(fit.v$coefficients)
df <- data.frame(twoD = x$s.v,
                 threeD = x$db.v, 
                 slope = rep(fit.v[1,1], len= nrow(x)))

delta <- nrow(df) * sum(df$twoD^2) - (sum(df$twoD))^2
sigma.y <- sqrt(1/(nrow(df)-2)*sum((df$threeD - 0 - df$twoD*df$slope)^2))
uncert.slope <- sigma.y * sqrt(nrow(df)/delta)
}


#SLOPE UNCERT, INTERCEPT /=/ 0, FT
sigma.slope.ft <- function(linreg, x) {
fit.ft <- summary(linreg)
fit.ft <- data.frame(fit.ft$coefficients)
df <- data.frame(twoD = x$s.ft,
                 threeD = x$db.ft, 
                 intercept = rep(fit.ft[1,1], len=nrow(x)), 
                 slope = rep(fit.ft[2,1], len= nrow(x)))

delta <- nrow(df) * sum(df$twoD^2) - (sum(df$twoD))^2
sigma.y <- sqrt(1/(nrow(df)-2)*sum((df$threeD - df$intercept - df$twoD*df$slope)^2))
uncert.slope <- sigma.y * sqrt(nrow(df)/delta)
}
#INTERCEPT UNCERT, INTERCEPT /=/ 0, FT
sigma.incp.ft <- function(linreg, x) {
fit.ft <- summary(linreg)
fit.ft <- data.frame(fit.ft$coefficients)
df <- data.frame(twoD = x$s.ft,
                 threeD = x$db.ft, 
                 intercept = rep(fit.ft[1,1], len=nrow(x)), 
                 slope = rep(fit.ft[2,1], len= nrow(x)))
delta <- nrow(df) * sum(df$twoD^2) - (sum(df$twoD))^2
sigma.y <- sqrt(1/(nrow(df)-2)*sum((df$threeD - df$intercept - df$twoD*df$slope)^2))
uncert.incept <- sigma.y * sqrt((sum(df$twoD^2))/delta)
}


#SLOPE UNCERT, INTERCEPT /=/ -, VOLUME
sigma.slope.v <- function(linreg, x) {
fit.v <- summary(linreg)
fit.v <- data.frame(fit.v$coefficients)
df <- data.frame(twoD = x$s.v,
                 threeD = x$db.v, 
                 intercept = rep(fit.v[1,1], len=nrow(x)), 
                 slope = rep(fit.v[2,1], len= nrow(x)))

delta <- nrow(df) * sum(df$twoD^2) - (sum(df$twoD))^2
sigma.y <- sqrt(1/(nrow(df)-2)*sum((df$threeD - df$intercept - df$twoD*df$slope)^2))
uncert.slope <- sigma.y * sqrt(nrow(df)/delta)
}
#INTERCEPT UNCERT, INTERCEPT /=/ 0, VOLUME
sigma.incp.v <- function(linreg, x) {
fit.v <- summary(linreg)
fit.v <- data.frame(fit.v$coefficients)
df <- data.frame(twoD = x$s.v,
                 threeD = x$db.v, 
                 intercept = rep(fit.v[1,1], len=nrow(x)), 
                 slope = rep(fit.v[2,1], len= nrow(x)))

delta <- nrow(df) * sum(df$twoD^2) - (sum(df$twoD))^2
sigma.y <- sqrt(1/(nrow(df)-2)*sum((df$threeD - df$intercept - df$twoD*df$slope)^2))
uncert.incept <- sigma.y * sqrt((sum(df$twoD^2))/delta)
}


#Function that produces the normalized residual standard error [must run code chunk that adds residual values to dataframe]
norm.rse <- function(n.resid, n) {
  sqrt((sum((n.resid)^2)/(n-2)))
}

#Function that produces the normalized residual standard error [must run code chunk that adds residual values to dataframe]
norm.rse <- function(n.resid, n) {
  sqrt((sum((n.resid)^2)/(n-2)))
}


```


#Stats Data for A & B- Ft
```{r}
x <- 
robust.ft <- lm(db.ft ~ s.ft, data=x)

#Append Residuals to Dataframes & Calculated Norm. Residual Std Error 
df.ft.resid <- x %>%
  mutate(s.ft.resid = resid(robust.ft)) %>%
  mutate(s.ft.resid.norm = s.ft.resid/db.ft) %>%
  mutate(s.ft.resid.norm.percent = s.ft.resid.norm*100)
n.resid <- df.ft.resid$s.ft.resid.norm
n <- nrow(df.ft.resid)

norm <- norm.rse(n.resid, n)

#For A & B GEM-- formatted for "normal" slope + intercept data
uncert.slope.ft <- sigma.slope.ft(robust.ft, x)
uncert.incep.ft <- sigma.incp.ft(robust.ft, x)


#Create dataframe with values I need
values <- summary(robust.ft)
stats.df.ft <- rbind(slope=values$coefficients[2,1], sigma.slope = uncert.slope.ft, intercept=values$coefficients[1,1], sigma.intercept = uncert.incep.ft, norm.std.error=norm, std.error=values$sigma)
stats.df.ft<- as.data.frame(t(as.matrix(stats.df.ft)))
```

#Stats Data for Fixed Intercept- Ft
```{r}
x <- 
robust.zero.ft <- lm(db.ft ~ 0 + s.ft, data=x)

#Append Residuals to Dataframes & Calculated Norm. Residual Std Error 
y<- resid(robust.zero.ft, na.action = na.exclude)

df.ft.resid <- x %>%
  mutate(s.ft.resid = y) %>%
  mutate(s.ft.resid.norm = s.ft.resid/db.ft) %>%
  mutate(s.ft.resid.norm.percent = s.ft.resid.norm*100)
n.resid <- df.ft.resid$s.ft.resid.norm
n <- nrow(df.ft.resid)

norm <- norm.rse(n.resid, n)

#Uncertainty in slope and intercept
uncert.slope.ft <- slope.uncertainty.ft(robust.zero.ft, x)

#Create dataframe with values I need
values <- summary(robust.zero.ft)
stats.df.ft <- rbind(slope=values$coefficients[1,1], sigma.slope = uncert.slope.ft, intercept=0, sigma.intercept = 0, norm.std.error=norm, std.error=values$sigma)
stats.df.ft <- as.data.frame(t(as.matrix(stats.df.ft)))
```

#Stats Data for A & B- Volume
```{r}
x <- df.ab
robust.v <- lm(db.v ~ s.v, data=x)

#Append Residuals to Dataframes & Calculated Norm. Residual Std Error 
df.v.resid <- x %>%
  mutate(s.v.resid = resid(robust.v)) %>%
  mutate(s.v.resid.norm = s.v.resid/db.v) %>%
  mutate(s.v.resid.norm.percent = s.v.resid.norm *100) 

n.resid <- df.v.resid$s.v.resid.norm
n <- nrow(df.v.resid)

norm <- norm.rse(n.resid, n)

#For A & B GEM-- formatted for "normal" slope + intercept data
uncert.slope.v <- sigma.slope.v(robust.v, x)
uncert.incep.v <- sigma.incp.v(robust.v, x)

#Create dataframe with values I need
values <- summary(robust.v)
stats.df.v <- rbind(slope=values$coefficients[2,1], sigma.slope = uncert.slope.v, intercept=values$coefficients[1,1], sigma.intercept = uncert.incep.v, norm.std.error=norm, std.error=values$sigma)
stats.df.v<- as.data.frame(t(as.matrix(stats.df.v)))
```

#Stats Data for C - Volume
```{r}
x <- df.c3
robust.zero.v <- lm(db.v ~ 0 + s.v, data=x)

#Append Residuals to Dataframes & Calculated Norm. Residual Std Error 
df.v.resid <- x %>%
  mutate(s.v.resid = resid(robust.zero.v)) %>%
  mutate(s.v.resid.norm = s.v.resid/db.v) %>%
  mutate(s.v.resid.norm.percent = s.v.resid.norm *100) 

n.resid <- df.v.resid$s.v.resid.norm
n <- nrow(df.v.resid)

norm <- norm.rse(n.resid, n)

#For A & B GEM-- formatted for "normal" slope + intercept data
uncert.slope.v <- sigma.slope.v.fixed.incp(robust.zero.v, x)

#Create dataframe with values I need
values <- summary(robust.zero.v)
stats.df.v <- rbind(slope=values$coefficients[1,1], sigma.slope = uncert.slope.v, intercept=0, sigma.intercept = 0, norm.std.error=norm, std.error=values$sigma)
stats.df.v<- as.data.frame(t(as.matrix(stats.df.v)))
```




