sample_df <- df %>%
select(sample, s.gem, s.v,  db.v) %>%
rename(twoD = s.v,  threeD = db.v)
}
if (param == "esr") {
sample_df <- df %>%
select(sample, s.gem, s.esr.ft, db.esr.ft) %>%
rename(twoD = s.esr.ft, threeD = db.esr.ft)
}
# Set set.seed a starting number to generate a sequence of random numbers so that we can get reproducible results
set.seed(123)
#Perform bootstrap
sample_boot <- bootstraps(sample_df,
times = 1000,
apparent = TRUE)
#Run linear regression on each bootstrap
sample_models <- sample_boot %>%
mutate(model = map(splits, ~ lm(twoD ~ 0 + threeD,
data = .) ),
coef_inf = map(model, tidy))
#Get coefficients
sample_coefs <<- sample_models %>%
unnest(coef_inf)
#Get confidence interval
percentile_intervals <- int_pctl(sample_models,
coef_inf)
#Store residuals for each bootstrapped sample
res <- matrix(nrow = nrow(df), ncol = 1001)
df <- enquo(df)
for (i in 1:1001) {
res[,i] <- unname(sample_coefs[[3]][[i]]$residuals)
assign(paste("residuals", glue(!!"{df}"), sep = "_"), res, envir = parent.frame())
}
#Store results
results <<- as.data.frame(cbind(percentile_intervals$.estimate, mean(sample_coefs$std.error), (1/percentile_intervals$.estimate))) %>%
rename(slope = V1, std.error = V2, plot.slope= V3)
slopes <<- sample_coefs$estimate
print(results)
}
bootstrap.linreg(gcb, "ft", "a")
bootstrap.linreg <- function(df, param, df_name) {
if (param == "ft") {
sample_df <- df %>%
select(sample, s.gem, s.ft,  db.ft) %>%
rename(twoD = s.ft, threeD = db.ft)
}
if (param == "volume") {
sample_df <- df %>%
select(sample, s.gem, s.v,  db.v) %>%
rename(twoD = s.v,  threeD = db.v)
}
if (param == "esr") {
sample_df <- df %>%
select(sample, s.gem, s.esr.ft, db.esr.ft) %>%
rename(twoD = s.esr.ft, threeD = db.esr.ft)
}
# Set set.seed a starting number to generate a sequence of random numbers so that we can get reproducible results
set.seed(123)
#Perform bootstrap
sample_boot <- bootstraps(sample_df,
times = 1000,
apparent = TRUE)
#Run linear regression on each bootstrap
sample_models <- sample_boot %>%
mutate(model = map(splits, ~ lm(twoD ~ 0 + threeD,
data = .) ),
coef_inf = map(model, tidy))
#Get coefficients
sample_coefs <<- sample_models %>%
unnest(coef_inf)
#Get confidence interval
percentile_intervals <- int_pctl(sample_models,
coef_inf)
#Store residuals for each bootstrapped sample
res <- matrix(nrow = nrow(df), ncol = 1001)
for (i in 1:1001) {
res[,i] <- unname(sample_coefs[[3]][[i]]$residuals)
assign(paste("residuals", glue("{df_name}"), sep = "_"), res, envir = parent.frame())
}
#Store results
results <<- as.data.frame(cbind(percentile_intervals$.estimate, mean(sample_coefs$std.error), (1/percentile_intervals$.estimate))) %>%
rename(slope = V1, std.error = V2, plot.slope= V3)
slopes <<- sample_coefs$estimate
print(results)
}
# Chunk 1: setup
#for stats
library(MASS)
library(performance) #check model
library(tidymodels)
#tidyverse
library(tidyverse) #purr, dplyr, tidyr, readr, readxl, tibble, stringr, forcats, ggplot2
library(broom)
library(scales)
library(readxl)
library(glue)
#for viz
library(plotly)
library(patchwork)
library(RColorBrewer)
library(colorspace)
library(jcolors)
library(viridis)
library(ggsci)
library(ggthemes)
#for knitting
library(knitr)
library(tinytex)
library(latex2exp)
#library(xlsx)
#library(datapaste)
par(mfrow=c(1, 1)) #how to arrange plots, 1 per row, 1 per column
#Theme options
theme_set(theme_light())
theme_update(plot.title = element_text(hjust = 0.5)) #adjusts theme so that all titles are centered
theme_update(plot.subtitle= element_text(hjust = 0.5)) #adjusts subtitle so they are all centered
#options(scipen = -1) #prints numbers instead of scientific notation
# Chunk 2
apatite <- read_excel("./Data Comps_v7.xlsx", sheet="Data Comps")
as_tibble(apatite)
apatite <- apatite %>%
filter(!is.na(apatite$empty)) #this gets rid of data points that are missing information
# Chunk 3
apatite$size.bin <- factor(apatite$size.bin, levels = c("40-50", "51-60", "61-70", "71-80", "81-90", "91-100", "101-110", "111-120", "121-130", "131-140", "141-150", "151-160", "161-170"))
apatite$s.gem <- factor(apatite$s.gem, levels = c("A1", "A2", "A3", "B1", "B2", "B3", "C1", "C2", "C3"))
apatite$ri <- factor(df7.rm$ri, levels = c("1", "2", "3"))
apatite$size.name <- factor(apatite$size.name, levels=c("Small & Rare","Small & Common","Typical & Common", "Large & Common", "Large & Rare"))
apatite$gem.cat <- factor(apatite$gem.cat, levels = c("Best.GEM", "Average.GEM", "Worst.GEM"))
apatite$np <- factor(apatite$np, levels= c("0", "1", "2"))
# Chunk 4
quad <- read_excel("./Linear Reg Results.xlsx", sheet="comp")
# Chunk 5
#Grains Removed
common_apatite <- apatite %>%
filter(!size.name == "Large & Rare", !size.name == "Small & Rare")
# Chunk 6
#Dataframe by Roughness Index
ri1 <- common_apatite %>% filter(ri=="1")
ri2 <- common_apatite %>% filter(ri=="2")
ri3 <- common_apatite %>% filter(ri=="3")
#Dataframe by Geometric Classification
gca <- common_apatite %>% filter(gc=="A")
gcb <- common_apatite %>% filter(gc=="B")
gcc <- common_apatite %>% filter(gc=="C")
ab <- common_apatite %>% filter(gc == "A" | gc == "B") %>% mutate(s.gem= "AB")
#Create Dataframes split by both geometry and roughness
a1 <- common_apatite %>% filter(s.gem == "A1")
a2 <- common_apatite %>% filter(s.gem == "A2")
a3 <- common_apatite %>% filter(s.gem == "A3")
b1 <- common_apatite %>% filter(s.gem == "B1")
b2 <- common_apatite %>% filter(s.gem == "B2")
b3 <- common_apatite %>% filter(s.gem == "B3")
c1 <- common_apatite %>% filter(s.gem == "C1")
c2 <- common_apatite %>% filter(s.gem == "C2")
c3 <- common_apatite %>% filter(s.gem == "C3")
#Make dataframes based on terminations
term0 <- common_apatite %>% filter(np == "0")
term1 <- common_apatite %>% filter(np == "1")
term2 <- common_apatite %>% filter(np =="2")
# Chunk 7
source("function_error_propagation.R")
source("function_bootstrapped_slopes.R")
source("function_linreg_slope_uncertainty.R")
source("function_model_diagnostics.R")
# Chunk 8
source("function_error_lines.R")
source("function_plot_results.R")
View(bootstrap.linreg)
bootstrap.linreg <- function(df, param, df_name) {
if (param == "ft") {
sample_df <- df %>%
select(sample, s.gem, s.ft,  db.ft) %>%
rename(twoD = s.ft, threeD = db.ft)
}
if (param == "volume") {
sample_df <- df %>%
select(sample, s.gem, s.v,  db.v) %>%
rename(twoD = s.v,  threeD = db.v)
}
if (param == "esr") {
sample_df <- df %>%
select(sample, s.gem, s.esr.ft, db.esr.ft) %>%
rename(twoD = s.esr.ft, threeD = db.esr.ft)
}
# Set set.seed a starting number to generate a sequence of random numbers so that we can get reproducible results
set.seed(123)
#Perform bootstrap
sample_boot <- bootstraps(sample_df,
times = 1000,
apparent = TRUE)
#Run linear regression on each bootstrap
sample_models <- sample_boot %>%
mutate(model = map(splits, ~ lm(twoD ~ 0 + threeD,
data = .) ),
coef_inf = map(model, tidy))
#Get coefficients
sample_coefs <<- sample_models %>%
unnest(coef_inf)
#Get confidence interval
percentile_intervals <- int_pctl(sample_models,
coef_inf)
#Store residuals for each bootstrapped sample
res <- matrix(nrow = nrow(df), ncol = 1001)
for (i in 1:1001) {
res[,i] <- unname(sample_coefs[[3]][[i]]$residuals)
assign(paste("residuals", glue("{df_name}"), sep = "_"), res, envir = parent.frame())
}
#Store results
results <<- as.data.frame(cbind(percentile_intervals$.estimate, mean(sample_coefs$std.error), (1/percentile_intervals$.estimate))) %>%
rename(slope = V1, std.error = V2, plot.slope= V3)
assign(paste("slopes", glue("{df_name}"), sep = "_"), sample_coefs$estimate, envir = parent.frame())
print(results)
}
bootstrap.linreg <- function(df, param, df_name) {
if (param == "ft") {
sample_df <- df %>%
select(sample, s.gem, s.ft,  db.ft) %>%
rename(twoD = s.ft, threeD = db.ft)
}
if (param == "volume") {
sample_df <- df %>%
select(sample, s.gem, s.v,  db.v) %>%
rename(twoD = s.v,  threeD = db.v)
}
if (param == "esr") {
sample_df <- df %>%
select(sample, s.gem, s.esr.ft, db.esr.ft) %>%
rename(twoD = s.esr.ft, threeD = db.esr.ft)
}
# Set set.seed a starting number to generate a sequence of random numbers so that we can get reproducible results
set.seed(123)
#Perform bootstrap
sample_boot <- bootstraps(sample_df,
times = 1000,
apparent = TRUE)
#Run linear regression on each bootstrap
sample_models <- sample_boot %>%
mutate(model = map(splits, ~ lm(twoD ~ 0 + threeD,
data = .) ),
coef_inf = map(model, tidy))
#Get coefficients
sample_coefs <<- sample_models %>%
unnest(coef_inf)
#Get confidence interval
percentile_intervals <- int_pctl(sample_models,
coef_inf)
#Store residuals for each bootstrapped sample
res <- matrix(nrow = nrow(df), ncol = 1001)
for (i in 1:1001) {
res[,i] <- unname(sample_coefs[[3]][[i]]$residuals)
assign(paste("residuals", glue("{df_name}"), glue("{param}"), sep = "_"), res, envir = parent.frame())
}
#Store results
results <<- as.data.frame(cbind(percentile_intervals$.estimate, mean(sample_coefs$std.error), (1/percentile_intervals$.estimate))) %>%
rename(slope = V1, std.error = V2, plot.slope= V3)
assign(paste("slopes", glue("{df_name}"), glue("{param}"), sep = "_"), sample_coefs$estimate, envir = parent.frame())
print(results)
}
bootstrap.linreg(gca, "ft", "a")
bootstrap.linreg <- function(df, param, df_name) {
if (param == "ft") {
sample_df <- df %>%
select(sample, s.gem, s.ft,  db.ft) %>%
rename(twoD = s.ft, threeD = db.ft)
}
if (param == "volume") {
sample_df <- df %>%
select(sample, s.gem, s.v,  db.v) %>%
rename(twoD = s.v,  threeD = db.v)
}
if (param == "esr") {
sample_df <- df %>%
select(sample, s.gem, s.esr.ft, db.esr.ft) %>%
rename(twoD = s.esr.ft, threeD = db.esr.ft)
}
# Set set.seed a starting number to generate a sequence of random numbers so that we can get reproducible results
set.seed(123)
#Perform bootstrap
sample_boot <- bootstraps(sample_df,
times = 1000,
apparent = TRUE)
#Run linear regression on each bootstrap
sample_models <- sample_boot %>%
mutate(model = map(splits, ~ lm(twoD ~ 0 + threeD,
data = .) ),
coef_inf = map(model, tidy))
#Get coefficients
sample_coefs <<- sample_models %>%
unnest(coef_inf)
#Get confidence interval
percentile_intervals <- int_pctl(sample_models,
coef_inf)
#Store residuals for each bootstrapped sample
res <- matrix(nrow = nrow(df), ncol = 1001)
for (i in 1:1001) {
res[,i] <- unname(sample_coefs[[3]][[i]]$residuals)
assign(paste("residuals", glue("{df_name}"), glue("{param}"), sep = "_"), res, envir = parent.frame())
}
#Store results
results <<- as.data.frame(cbind(percentile_intervals$.estimate, mean(sample_coefs$std.error), (1/percentile_intervals$.estimate))) %>%
rename(slope = V1, std.error = V2, plot.slope= V3)
as.data.frame(assign(paste("slopes", glue("{df_name}"), glue("{param}"), sep = "_"), sample_coefs$estimate, envir = parent.frame()))
print(results)
}
bootstrap.linreg(gca, "ft", "a")
bootstrap.linreg <- function(df, param, df_name) {
if (param == "ft") {
sample_df <- df %>%
select(sample, s.gem, s.ft,  db.ft) %>%
rename(twoD = s.ft, threeD = db.ft)
}
if (param == "volume") {
sample_df <- df %>%
select(sample, s.gem, s.v,  db.v) %>%
rename(twoD = s.v,  threeD = db.v)
}
if (param == "esr") {
sample_df <- df %>%
select(sample, s.gem, s.esr.ft, db.esr.ft) %>%
rename(twoD = s.esr.ft, threeD = db.esr.ft)
}
# Set set.seed a starting number to generate a sequence of random numbers so that we can get reproducible results
set.seed(123)
#Perform bootstrap
sample_boot <- bootstraps(sample_df,
times = 1000,
apparent = TRUE)
#Run linear regression on each bootstrap
sample_models <- sample_boot %>%
mutate(model = map(splits, ~ lm(twoD ~ 0 + threeD,
data = .) ),
coef_inf = map(model, tidy))
#Get coefficients
sample_coefs <<- sample_models %>%
unnest(coef_inf)
#Get confidence interval
percentile_intervals <- int_pctl(sample_models,
coef_inf)
#Store residuals for each bootstrapped sample
res <- matrix(nrow = nrow(df), ncol = 1001)
for (i in 1:1001) {
res[,i] <- unname(sample_coefs[[3]][[i]]$residuals)
as.data.frame(assign(paste("residuals", glue("{df_name}"), glue("{param}"), sep = "_"), res, envir = parent.frame()))
}
#Store results
results <<- as.data.frame(cbind(percentile_intervals$.estimate, mean(sample_coefs$std.error), (1/percentile_intervals$.estimate))) %>%
rename(slope = V1, std.error = V2, plot.slope= V3)
as.data.frame(assign(paste("slopes", glue("{df_name}"), glue("{param}"), sep = "_"), sample_coefs$estimate, envir = parent.frame()))
print(results)
}
bootstrap.linreg(gca, "ft", "a")
bootstrap.linreg <- function(df, param, df_name) {
if (param == "ft") {
sample_df <- df %>%
select(sample, s.gem, s.ft,  db.ft) %>%
rename(twoD = s.ft, threeD = db.ft)
}
if (param == "volume") {
sample_df <- df %>%
select(sample, s.gem, s.v,  db.v) %>%
rename(twoD = s.v,  threeD = db.v)
}
if (param == "esr") {
sample_df <- df %>%
select(sample, s.gem, s.esr.ft, db.esr.ft) %>%
rename(twoD = s.esr.ft, threeD = db.esr.ft)
}
# Set set.seed a starting number to generate a sequence of random numbers so that we can get reproducible results
set.seed(123)
#Perform bootstrap
sample_boot <- bootstraps(sample_df,
times = 1000,
apparent = TRUE)
#Run linear regression on each bootstrap
sample_models <- sample_boot %>%
mutate(model = map(splits, ~ lm(twoD ~ 0 + threeD,
data = .) ),
coef_inf = map(model, tidy))
#Get coefficients
sample_coefs <<- sample_models %>%
unnest(coef_inf)
#Get confidence interval
percentile_intervals <- int_pctl(sample_models,
coef_inf)
#Store residuals for each bootstrapped sample
res <- matrix(nrow = nrow(df), ncol = 1001)
for (i in 1:1001) {
res[,i] <- unname(sample_coefs[[3]][[i]]$residuals)
as.data.frame(assign(paste("residuals", glue("{df_name}"), glue("{param}"), sep = "_"), res, envir = parent.frame()))
}
#Store results
results <<- as.data.frame(cbind(percentile_intervals$.estimate, mean(sample_coefs$std.error), (1/percentile_intervals$.estimate))) %>%
rename(slope = V1, std.error = V2, plot.slope= V3)
tibble(assign(paste("slopes", glue("{df_name}"), glue("{param}"), sep = "_"), sample_coefs$estimate, envir = parent.frame()))
print(results)
}
bootstrap.linreg(gca, "ft", "a")
as.data.frame(slopes_a_ft)
?assign
bootstrap.linreg <- function(df, param, df_name) {
if (param == "ft") {
sample_df <- df %>%
select(sample, s.gem, s.ft,  db.ft) %>%
rename(twoD = s.ft, threeD = db.ft)
}
if (param == "volume") {
sample_df <- df %>%
select(sample, s.gem, s.v,  db.v) %>%
rename(twoD = s.v,  threeD = db.v)
}
if (param == "esr") {
sample_df <- df %>%
select(sample, s.gem, s.esr.ft, db.esr.ft) %>%
rename(twoD = s.esr.ft, threeD = db.esr.ft)
}
# Set set.seed a starting number to generate a sequence of random numbers so that we can get reproducible results
set.seed(123)
#Perform bootstrap
sample_boot <- bootstraps(sample_df,
times = 1000,
apparent = TRUE)
#Run linear regression on each bootstrap
sample_models <- sample_boot %>%
mutate(model = map(splits, ~ lm(twoD ~ 0 + threeD,
data = .) ),
coef_inf = map(model, tidy))
#Get coefficients
sample_coefs <<- sample_models %>%
unnest(coef_inf)
#Get confidence interval
percentile_intervals <- int_pctl(sample_models,
coef_inf)
#Store residuals for each bootstrapped sample
res <- matrix(nrow = nrow(df), ncol = 1001)
for (i in 1:1001) {
res[,i] <- unname(sample_coefs[[3]][[i]]$residuals)
as.data.frame(assign(paste("residuals", glue("{df_name}"), glue("{param}"), sep = "_"), res, envir = parent.frame()))
}
#Store results
results <<- as.data.frame(cbind(percentile_intervals$.estimate, mean(sample_coefs$std.error), (1/percentile_intervals$.estimate))) %>%
rename(slope = V1, std.error = V2, plot.slope= V3)
as.data.frame(assign(paste("slopes", glue("{df_name}"), glue("{param}"), sep = "_"), sample_coefs$estimate, envir = parent.frame()))
print(results)
}
bootstrap.linreg(gcb, "ft", "b")
View(residuals_b_ft)
View(residuals_a_ft)
bootstrap.linreg <- function(df, param, df_name) {
if (param == "ft") {
sample_df <- df %>%
select(sample, s.gem, s.ft,  db.ft) %>%
rename(twoD = s.ft, threeD = db.ft)
}
if (param == "volume") {
sample_df <- df %>%
select(sample, s.gem, s.v,  db.v) %>%
rename(twoD = s.v,  threeD = db.v)
}
if (param == "esr") {
sample_df <- df %>%
select(sample, s.gem, s.esr.ft, db.esr.ft) %>%
rename(twoD = s.esr.ft, threeD = db.esr.ft)
}
# Set set.seed a starting number to generate a sequence of random numbers so that we can get reproducible results
set.seed(123)
#Perform bootstrap
sample_boot <- bootstraps(sample_df,
times = 1000,
apparent = TRUE)
#Run linear regression on each bootstrap
sample_models <- sample_boot %>%
mutate(model = map(splits, ~ lm(twoD ~ 0 + threeD,
data = .) ),
coef_inf = map(model, tidy))
#Get coefficients
sample_coefs <<- sample_models %>%
unnest(coef_inf)
#Get confidence interval
percentile_intervals <- int_pctl(sample_models,
coef_inf)
#Store residuals for each bootstrapped sample
res <- matrix(nrow = nrow(df), ncol = 1001)
for (i in 1:1001) {
res[,i] <- unname(sample_coefs[[3]][[i]]$residuals)
assign(paste("residuals", glue("{df_name}"), glue("{param}"), sep = "_"), res, envir = parent.frame())
}
#Store results
results_boot <<- as.data.frame(cbind(percentile_intervals$.estimate, mean(sample_coefs$std.error), (1/percentile_intervals$.estimate))) %>%
rename(slope = V1, std.error = V2, plot.slope= V3)
assign(paste("slopes", glue("{df_name}"), glue("{param}"), sep = "_"), sample_coefs$estimate, envir = parent.frame())
print(results)
}
ttest_compare <- function (x, y) {
t <- t.test(x,y)
#Ho: the slopes are equal
#H1: the slopes are not equal
#if p < 0.05, reject the null hypothesis (ie. H1 is true!)
interpretation <- if (t$p.value > 0.05) {
"The slopes are the same"
} else {
"The slopes are different"
}
results_ttest <<- as.data.frame(cbind(t$p.value, interpretation)) %>%
rename(p.value = V1)
return(results_ttest)
}
ttest_results(slopes_a_ft, slopes_b_ft)
ttest_compare(slopes_a_ft, slopes_b_ft)
bootstrap.linreg(gcc, "ft", "c")
ttest_compare(slopes_a_ft, slopes_c_ft)
tidy(t.test(slopes_a_ft, slopes_c_ft))
t.test(slopes_a_ft, slopes_c_ft)
