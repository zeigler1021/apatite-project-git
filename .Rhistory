param <-  "esr"
#MUST CHANGE THIS FOR EACH PARAMETER YOU WANT TO RUN #ie. "ft", "volume", "esr"
results_boot <- pmap(list(sample_df[[3]],
glue("{param}")),
bootstrap.linreg.nest)
# Convert the lists of lists spit out by 'map' into a dataframe that is pretty & in the correct order.
# Seperate slopes from other results
results_flat <- flatten(results_boot)
results_boot <- results_flat[seq(1, length(results_flat), 2)]
slopes_boot <- results_flat[seq(2, length(results_flat), 2)]
# results --> tidy dataframe
results_boot_df <- data.frame(matrix(unlist(results_boot), nrow = 11, byrow = T)) %>%
rename(slope = X1, std.err = X2, plot.slope = X3) %>%
bind_cols(sample_df[,2]) %>%
relocate(grouping, .before = slope) %>%
tibble() %>%
mutate(grouping = factor(grouping, levels = c("A", "A1", "A2", "B", "B1", "B2", "1", "2", "term0", "term1", "term2"))) %>%
arrange(grouping)
#Save results to named dataframe
assign(paste("results_boot", glue("{param}"), sep =  "_"), results_boot_df)
# slopes --> tidy dataframe
# To calculate an uncertainty on the correction, a vector of all 1001 slopes split out by the bootstrapping procedure is saved into its own file.
slopes_boot_df <- data.frame(matrix(unlist(slopes_boot), nrow = 1001, byrow = FALSE)) %>%
rename(A1 = X1, A = X2, `1` = X3, term1 = X4, term2 = X5, A2 = X6, `2`= X7, term0 = X8, B2 = X9, B = X10, B1 = X11) %>%
tibble() %>%
select("A", "A1", "A2", "B", "B1", "B2", "1", "2", "term0", "term1", "term2")
#Save results to named dataframe
assign(paste("slopes_boot", glue("{param}"), sep =  "_"), slopes_boot_df)
filename <- "Regression Results_Final.xlsx"
###### Bootstrapped results,intercept fixed at zero
xlsx::write.xlsx(as.data.frame(results_boot_ft), file = glue("{filename}"), sheetName="results_boot_ft", append = TRUE, row.names=FALSE)
xlsx::write.xlsx(as.data.frame(results_boot_volume), file = glue("{filename}"), sheetName="results_boot_volume", row.names=FALSE, append = TRUE)
xlsx::write.xlsx(as.data.frame(results_boot_esr), file=glue("{filename}"), sheetName="results_boot_esr", row.names=FALSE, append = TRUE)
###### Slopes, bootstrapped, intercept fixed at zero
xlsx::write.xlsx(as.data.frame(slopes_boot_ft), file=glue("{filename}"), sheetName="slopes_boot_ft", row.names=FALSE, append = TRUE)
xlsx::write.xlsx(as.data.frame(slopes_boot_volume), file=glue("{filename}"), sheetName="slopes_boot_volume", row.names=FALSE, append = TRUE)
xlsx::write.xlsx(as.data.frame(slopes_boot_esr), file=glue("{filename}"), sheetName="slopes_boot_esr", row.names=FALSE, append = TRUE)
View(bootstrap.intercepts)
View(bootstrap.linreg.nest)
View(bootstrap.linreg.nest)
View(bootstrap.linreg.nest.not.fixed)
bootstrap.linreg.nest.not.fixed <- function (x, param) {
# Set set.seed a starting number to generate a sequence of random numbers so that we can get reproducible results
set.seed(123)
#Perform bootstrap
sample_boot <- bootstraps(x,
times = 1000,
apparent = TRUE)
#Run linear regression on each bootstrap
if (param == "ft") {
sample_models <- sample_boot %>%
mutate(model = map(splits, ~ lm(s.ft ~ db.ft,
data = .)),
coef_inf = map(model, tidy))
#Get coefficients
sample_coefs <- sample_models %>%
unnest(coef_inf)
#Get confidence interval
#percentile_intervals <- int_pctl(sample_models,coef_inf)
#Retrieve intercepts and means
intercept_coefs <- sample_coefs %>% select(term, estimate) %>% filter(term == "(Intercept)")
slope_coefs <- sample_coefs %>% select(term, estimate) %>% filter(term == "db.ft")
}
if (param == "volume")  {
sample_models <- sample_boot %>%
mutate(model = map(splits, ~ lm(s.v ~ db.v,
data = .)),
coef_inf = map(model, tidy))
#Get coefficients
sample_coefs <- sample_models %>%
unnest(coef_inf)
#Get confidence interval
#percentile_intervals <- int_pctl(sample_models,coef_inf)
#Retrieve intercepts and means
intercept_coefs <- sample_coefs %>% select(term, estimate) %>% filter(term == "(Intercept)")
slope_coefs <- sample_coefs %>% select(term, estimate) %>% filter(term == "db.v")
}
if (param == "esr") {
sample_models <- sample_boot %>%
mutate(model = map(splits, ~ lm(s.esr.ft ~ db.esr.ft,
data = .)),
coef_inf = map(model, tidy))
#Get coefficients
sample_coefs <- sample_models %>%
unnest(coef_inf)
#Get confidence interval
#percentile_intervals <- int_pctl(sample_models,coef_inf)
#Retrieve intercepts and means
intercept_coefs <- sample_coefs %>% select(term, estimate) %>% filter(term == "(Intercept)")
slope_coefs <- sample_coefs %>% select(term, estimate) %>% filter(term == "db.esr.ft")
}
#Store results
slope <-  mean(slope_coefs$estimate)
intercept <- mean(intercept_coefs$estimate)
std.err <- mean(sample_coefs$std.error)
plot.slope <- 1/(mean(slope_coefs$estimate))
intercept_boot <- sample_coefs %>% select(term, estimate) %>% filter(term == "(Intercept)") %>% select(estimate)
slope_boot <- slope_coefs
results_boot <- as.data.frame(cbind(slope, intercept, std.err, plot.slope))
results_boot_list <- list(results_boot, intercept_boot, slope_boot)
return(results_boot_list)
#assign(paste(glue("{df_name}"), "slopes", glue("{param}"), sep = "_"), sample_coefs$estimate, envir = parent.frame())
#assign("boot_slopes", slopes_boot, envir = parent.frame())
}
bootstrap.linreg.nest.not.fixed <- function (x, param) {
# Set set.seed a starting number to generate a sequence of random numbers so that we can get reproducible results
set.seed(123)
#Perform bootstrap
sample_boot <- bootstraps(x,
times = 1000,
apparent = TRUE)
#Run linear regression on each bootstrap
if (param == "ft") {
sample_models <- sample_boot %>%
mutate(model = map(splits, ~ lm(s.ft ~ db.ft,
data = .)),
coef_inf = map(model, tidy))
#Get coefficients
sample_coefs <- sample_models %>%
unnest(coef_inf)
#Get confidence interval
#percentile_intervals <- int_pctl(sample_models,coef_inf)
#Retrieve intercepts and means
intercept_coefs <- sample_coefs %>% select(term, estimate) %>% filter(term == "(Intercept)")
slope_coefs <- sample_coefs %>% select(term, estimate) %>% filter(term == "db.ft")
}
if (param == "volume")  {
sample_models <- sample_boot %>%
mutate(model = map(splits, ~ lm(s.v ~ db.v,
data = .)),
coef_inf = map(model, tidy))
#Get coefficients
sample_coefs <- sample_models %>%
unnest(coef_inf)
#Get confidence interval
#percentile_intervals <- int_pctl(sample_models,coef_inf)
#Retrieve intercepts and means
intercept_coefs <- sample_coefs %>% select(term, estimate) %>% filter(term == "(Intercept)")
slope_coefs <- sample_coefs %>% select(term, estimate) %>% filter(term == "db.v")
}
if (param == "esr") {
sample_models <- sample_boot %>%
mutate(model = map(splits, ~ lm(s.esr.ft ~ db.esr.ft,
data = .)),
coef_inf = map(model, tidy))
#Get coefficients
sample_coefs <- sample_models %>%
unnest(coef_inf)
#Get confidence interval
#percentile_intervals <- int_pctl(sample_models,coef_inf)
#Retrieve intercepts and means
intercept_coefs <- sample_coefs %>% select(term, estimate) %>% filter(term == "(Intercept)")
slope_coefs <- sample_coefs %>% select(term, estimate) %>% filter(term == "db.esr.ft")
}
#Store results
slope <-  mean(slope_coefs$estimate)
intercept <- mean(intercept_coefs$estimate)
std.err <- mean(sample_coefs$std.error)
plot.slope <- 1/(mean(slope_coefs$estimate))
intercept_boot <- sample_coefs %>% select(term, estimate) %>% filter(term == "(Intercept)") %>% select(estimate)
slope_boot <- slope_coefs
results_boot <- as.data.frame(cbind(slope, intercept, std.err, plot.slope))
results_boot_list <- list(results_boot, intercept_boot, slope_boot)
return(results_boot_list)
#assign(paste(glue("{df_name}"), "slopes", glue("{param}"), sep = "_"), sample_coefs$estimate, envir = parent.frame())
#assign("boot_slopes", slopes_boot, envir = parent.frame())
}
param <- "ft" #MUST CHANGE THIS FOR EACH PARAMETER YOU WANT TO RUN #ie. "ft", "volume", "esr"
results_nf_boot <- pmap(list(sample_df[[3]],
glue("{param}")),
bootstrap.linreg.nest.not.fixed)
View(results_nf_boot)
# Convert the lists of lists spit out by 'map' into a dataframe that is pretty & in the correct order.
# Seperate slopes from other results
results_nf_flat <- flatten(results_nf_boot)
View(results_nf_flat)
bootstrap.linreg.nest.not.fixed <- function (x, param) {
# Set set.seed a starting number to generate a sequence of random numbers so that we can get reproducible results
set.seed(123)
#Perform bootstrap
sample_boot <- bootstraps(x,
times = 1000,
apparent = TRUE)
#Run linear regression on each bootstrap
if (param == "ft") {
sample_models <- sample_boot %>%
mutate(model = map(splits, ~ lm(s.ft ~ db.ft,
data = .)),
coef_inf = map(model, tidy))
#Get coefficients
sample_coefs <- sample_models %>%
unnest(coef_inf)
#Get confidence interval
#percentile_intervals <- int_pctl(sample_models,coef_inf)
#Retrieve intercepts and means
intercept_coefs <- sample_coefs %>% select(term, estimate) %>% filter(term == "(Intercept)")
slope_coefs <- sample_coefs %>% select(term, estimate) %>% filter(term == "db.ft")
}
if (param == "volume")  {
sample_models <- sample_boot %>%
mutate(model = map(splits, ~ lm(s.v ~ db.v,
data = .)),
coef_inf = map(model, tidy))
#Get coefficients
sample_coefs <- sample_models %>%
unnest(coef_inf)
#Get confidence interval
#percentile_intervals <- int_pctl(sample_models,coef_inf)
#Retrieve intercepts and means
intercept_coefs <- sample_coefs %>% select(term, estimate) %>% filter(term == "(Intercept)")
slope_coefs <- sample_coefs %>% select(term, estimate) %>% filter(term == "db.v")
}
if (param == "esr") {
sample_models <- sample_boot %>%
mutate(model = map(splits, ~ lm(s.esr.ft ~ db.esr.ft,
data = .)),
coef_inf = map(model, tidy))
#Get coefficients
sample_coefs <- sample_models %>%
unnest(coef_inf)
#Get confidence interval
#percentile_intervals <- int_pctl(sample_models,coef_inf)
#Retrieve intercepts and means
intercept_coefs <- sample_coefs %>% select(term, estimate) %>% filter(term == "(Intercept)")
slope_coefs <- sample_coefs %>% select(term, estimate) %>% filter(term == "db.esr.ft")
}
#Store results
slope <-  mean(slope_coefs$estimate)
intercept <- mean(intercept_coefs$estimate)
std.err <- mean(sample_coefs$std.error)
plot.slope <- 1/(mean(slope_coefs$estimate))
intercept_boot <- sample_coefs %>% select(term, estimate) %>% filter(term == "(Intercept)") %>% select(estimate)
slope_boot <- slope_coefs %>% select(estimate)
results_boot <- as.data.frame(cbind(slope, intercept, std.err, plot.slope))
results_boot_list <- list(results_boot, intercept_boot, slope_boot)
return(results_boot_list)
#assign(paste(glue("{df_name}"), "slopes", glue("{param}"), sep = "_"), sample_coefs$estimate, envir = parent.frame())
#assign("boot_slopes", slopes_boot, envir = parent.frame())
}
param <- "ft" #MUST CHANGE THIS FOR EACH PARAMETER YOU WANT TO RUN #ie. "ft", "volume", "esr"
results_nf_boot <- pmap(list(sample_df[[3]],
glue("{param}")),
bootstrap.linreg.nest.not.fixed)
# Convert the lists of lists spit out by 'map' into a dataframe that is pretty & in the correct order.
# Seperate slopes from other results
results_nf_flat <- flatten(results_nf_boot)
View(results_nf_boot)
View(results_nf_flat)
results_nf_boot <- results_nf_flat[seq(1, length(results_nf_flat), 3)]
View(results_nf_boot)
intercepts_boot <- results_nf_flat[seq(2, length(results_nf_flat), 3)]
View(intercepts_boot)
slopes_nf_boot <- results_nf_flat[seq(3, length(results_nf_flat), 3)]
View(slopes_nf_boot)
results_nf_boot_df <- data.frame(matrix(unlist(results_nf_boot), nrow = 11, byrow = T)) %>%
rename(slope = X1, intercept = X2, std.err = X3, plot.slope = X4) %>%
bind_cols(sample_df[,2]) %>%
relocate(grouping, .before = slope) %>%
tibble() %>%
mutate(grouping = factor(grouping, levels = c("A", "A1", "A2", "B", "B1", "B2", "1", "2", "term0", "term1", "term2"))) %>%
arrange(grouping)
#Save results to named dataframe
assign(paste("results_nf_boot", glue("{param}"), sep =  "_"), results_nf_boot_df)
intercepts_boot_df <- data.frame(matrix(unlist(intercepts_boot), nrow = 1001, byrow = FALSE)) %>%
rename(A1 = X1, A = X2, `1` = X3, term1 = X4, term2 = X5, A2 = X6, `2`= X7, term0 = X8, B2 = X9, B = X10, B1 = X11) %>%
tibble() %>%
select("A", "A1", "A2", "B", "B1", "B2", "1", "2", "term0", "term1", "term2")
#Save results to named dataframe
assign(paste("intercepts_boot", glue("{param}"), sep =  "_"), intercepts_boot_df)
slopes_nf_boot_df <- data.frame(matrix(unlist(slope_nf_boot), nrow = 1001, byrow = FALSE)) %>%
rename(A1 = X1, A = X2, `1` = X3, term1 = X4, term2 = X5, A2 = X6, `2`= X7, term0 = X8, B2 = X9, B = X10, B1 = X11) %>%
tibble() %>%
select("A", "A1", "A2", "B", "B1", "B2", "1", "2", "term0", "term1", "term2")
#Save results to named dataframe
assign(paste("slopes_nf_boot", glue("{param}"), sep =  "_"), slopes_nf_boot_df)
slopes_nf_boot_df <- data.frame(matrix(unlist(slopes_nf_boot), nrow = 1001, byrow = FALSE)) %>%
rename(A1 = X1, A = X2, `1` = X3, term1 = X4, term2 = X5, A2 = X6, `2`= X7, term0 = X8, B2 = X9, B = X10, B1 = X11) %>%
tibble() %>%
select("A", "A1", "A2", "B", "B1", "B2", "1", "2", "term0", "term1", "term2")
#Save results to named dataframe
assign(paste("slopes_nf_boot", glue("{param}"), sep =  "_"), slopes_nf_boot_df)
View(slopes_nf_boot_ft)
param <- "ft" #MUST CHANGE THIS FOR EACH PARAMETER YOU WANT TO RUN #ie. "ft", "volume", "esr"
results_nf_boot <- pmap(list(sample_df[[3]],
glue("{param}")),
bootstrap.linreg.nest.not.fixed)
# Convert the lists of lists spit out by 'map' into a dataframe that is pretty & in the correct order.
# Seperate slopes from other results
results_nf_flat <- flatten(results_nf_boot)
results_nf_boot <- results_nf_flat[seq(1, length(results_nf_flat), 3)]
intercepts_boot <- results_nf_flat[seq(2, length(results_nf_flat), 3)]
slopes_nf_boot <- results_nf_flat[seq(3, length(results_nf_flat), 3)]
results_nf_boot_df <- data.frame(matrix(unlist(results_nf_boot), nrow = 11, byrow = T)) %>%
rename(slope = X1, intercept = X2, std.err = X3, plot.slope = X4) %>%
bind_cols(sample_df[,2]) %>%
relocate(grouping, .before = slope) %>%
tibble() %>%
mutate(grouping = factor(grouping, levels = c("A", "A1", "A2", "B", "B1", "B2", "1", "2", "term0", "term1", "term2"))) %>%
arrange(grouping)
#Save results to named dataframe
assign(paste("results_nf_boot", glue("{param}"), sep =  "_"), results_nf_boot_df)
# intercepts --> tidy dataframe
# To calculate an uncertainty on the correction, a vector of all 1001 intercepts split out by the bootstrapping procedure is saved into its own file.
intercepts_boot_df <- data.frame(matrix(unlist(intercepts_boot), nrow = 1001, byrow = FALSE)) %>%
rename(A1 = X1, A = X2, `1` = X3, term1 = X4, term2 = X5, A2 = X6, `2`= X7, term0 = X8, B2 = X9, B = X10, B1 = X11) %>%
tibble() %>%
select("A", "A1", "A2", "B", "B1", "B2", "1", "2", "term0", "term1", "term2")
#Save results to named dataframe
assign(paste("intercepts_boot", glue("{param}"), sep =  "_"), intercepts_boot_df)
# slopes --> tidy dataframe
# To calculate an uncertainty on the correction, a vector of all 1001 slopes split out by the bootstrapping procedure is saved into its own file.
slopes_nf_boot_df <- data.frame(matrix(unlist(slopes_nf_boot), nrow = 1001, byrow = FALSE)) %>%
rename(A1 = X1, A = X2, `1` = X3, term1 = X4, term2 = X5, A2 = X6, `2`= X7, term0 = X8, B2 = X9, B = X10, B1 = X11) %>%
tibble() %>%
select("A", "A1", "A2", "B", "B1", "B2", "1", "2", "term0", "term1", "term2")
#Save results to named dataframe
assign(paste("slopes_nf_boot", glue("{param}"), sep =  "_"), slopes_nf_boot_df)
param <- "volume" #MUST CHANGE THIS FOR EACH PARAMETER YOU WANT TO RUN #ie. "ft", "volume", "esr"
results_nf_boot <- pmap(list(sample_df[[3]],
glue("{param}")),
bootstrap.linreg.nest.not.fixed)
# Convert the lists of lists spit out by 'map' into a dataframe that is pretty & in the correct order.
# Seperate slopes from other results
results_nf_flat <- flatten(results_nf_boot)
results_nf_boot <- results_nf_flat[seq(1, length(results_nf_flat), 3)]
intercepts_boot <- results_nf_flat[seq(2, length(results_nf_flat), 3)]
slopes_nf_boot <- results_nf_flat[seq(3, length(results_nf_flat), 3)]
results_nf_boot_df <- data.frame(matrix(unlist(results_nf_boot), nrow = 11, byrow = T)) %>%
rename(slope = X1, intercept = X2, std.err = X3, plot.slope = X4) %>%
bind_cols(sample_df[,2]) %>%
relocate(grouping, .before = slope) %>%
tibble() %>%
mutate(grouping = factor(grouping, levels = c("A", "A1", "A2", "B", "B1", "B2", "1", "2", "term0", "term1", "term2"))) %>%
arrange(grouping)
#Save results to named dataframe
assign(paste("results_nf_boot", glue("{param}"), sep =  "_"), results_nf_boot_df)
# intercepts --> tidy dataframe
# To calculate an uncertainty on the correction, a vector of all 1001 intercepts split out by the bootstrapping procedure is saved into its own file.
intercepts_boot_df <- data.frame(matrix(unlist(intercepts_boot), nrow = 1001, byrow = FALSE)) %>%
rename(A1 = X1, A = X2, `1` = X3, term1 = X4, term2 = X5, A2 = X6, `2`= X7, term0 = X8, B2 = X9, B = X10, B1 = X11) %>%
tibble() %>%
select("A", "A1", "A2", "B", "B1", "B2", "1", "2", "term0", "term1", "term2")
#Save results to named dataframe
assign(paste("intercepts_boot", glue("{param}"), sep =  "_"), intercepts_boot_df)
# slopes --> tidy dataframe
# To calculate an uncertainty on the correction, a vector of all 1001 slopes split out by the bootstrapping procedure is saved into its own file.
slopes_nf_boot_df <- data.frame(matrix(unlist(slopes_nf_boot), nrow = 1001, byrow = FALSE)) %>%
rename(A1 = X1, A = X2, `1` = X3, term1 = X4, term2 = X5, A2 = X6, `2`= X7, term0 = X8, B2 = X9, B = X10, B1 = X11) %>%
tibble() %>%
select("A", "A1", "A2", "B", "B1", "B2", "1", "2", "term0", "term1", "term2")
#Save results to named dataframe
assign(paste("slopes_nf_boot", glue("{param}"), sep =  "_"), slopes_nf_boot_df)
View(a1)
##### Bootstrapped results,intercept not fixed at zero
xlsx::write.xlsx(as.data.frame(results_nf_boot_ft), file="Regression Results_Final.xlsx", sheetName="results_nf_boot_ft", row.names=FALSE, append = TRUE)
xlsx::write.xlsx(as.data.frame(results_nf_boot_volume), file="Regression Results_Final.xlsx", sheetName="results_nf_boot_volume", row.names=FALSE, append = TRUE)
xlsx::write.xlsx(as.data.frame(results_nf_boot_esr), file="Regression Results_Final.xlsx", sheetName="results_nf_boot_esr", row.names=FALSE, append = TRUE)
###### Intercepts, bootstrapped, intercept not fixed at zero
xlsx::write.xlsx(as.data.frame(intercepts_boot_ft), file="Regression Results_Final.xlsx", sheetName="intercepts_boot_ft", row.names=FALSE, append = TRUE)
xlsx::write.xlsx(as.data.frame(intercepts_boot_volume), file="Regression Results_Final.xlsx", sheetName="intercepts_boot_volume", row.names=FALSE, append = TRUE)
xlsx::write.xlsx(as.data.frame(intercepts_boot_esr), file="Regression Results_Final.xlsx", sheetName="intercepts_boot_esr", row.names=FALSE, append = TRUE)
###### Slopes, bootstrapped, intercept not fixed at zero
xlsx::write.xlsx(as.data.frame(slopes_nf_boot_ft), file="Regression Results_Final.xlsx", sheetName="slopes_nf_boot_ft", row.names=FALSE, append = TRUE)
xlsx::write.xlsx(as.data.frame(slopes_nf_boot_volume), file="Regression Results_Final.xlsx", sheetName="slopes_nf_boot_volume", row.names=FALSE, append = TRUE)
xlsx::write.xlsx(as.data.frame(slopes_nf_boot_esr), file="Regression Results_Final.xlsx", sheetName="slopes_nf_boot_esr", row.names=FALSE, append = TRUE)
param <- "esr" #MUST CHANGE THIS FOR EACH PARAMETER YOU WANT TO RUN #ie. "ft", "volume", "esr"
results_nf_boot <- pmap(list(sample_df[[3]],
glue("{param}")),
bootstrap.linreg.nest.not.fixed)
# Convert the lists of lists spit out by 'map' into a dataframe that is pretty & in the correct order.
# Seperate slopes from other results
results_nf_flat <- flatten(results_nf_boot)
results_nf_boot <- results_nf_flat[seq(1, length(results_nf_flat), 3)]
intercepts_boot <- results_nf_flat[seq(2, length(results_nf_flat), 3)]
slopes_nf_boot <- results_nf_flat[seq(3, length(results_nf_flat), 3)]
results_nf_boot_df <- data.frame(matrix(unlist(results_nf_boot), nrow = 11, byrow = T)) %>%
rename(slope = X1, intercept = X2, std.err = X3, plot.slope = X4) %>%
bind_cols(sample_df[,2]) %>%
relocate(grouping, .before = slope) %>%
tibble() %>%
mutate(grouping = factor(grouping, levels = c("A", "A1", "A2", "B", "B1", "B2", "1", "2", "term0", "term1", "term2"))) %>%
arrange(grouping)
#Save results to named dataframe
assign(paste("results_nf_boot", glue("{param}"), sep =  "_"), results_nf_boot_df)
# intercepts --> tidy dataframe
# To calculate an uncertainty on the correction, a vector of all 1001 intercepts split out by the bootstrapping procedure is saved into its own file.
intercepts_boot_df <- data.frame(matrix(unlist(intercepts_boot), nrow = 1001, byrow = FALSE)) %>%
rename(A1 = X1, A = X2, `1` = X3, term1 = X4, term2 = X5, A2 = X6, `2`= X7, term0 = X8, B2 = X9, B = X10, B1 = X11) %>%
tibble() %>%
select("A", "A1", "A2", "B", "B1", "B2", "1", "2", "term0", "term1", "term2")
#Save results to named dataframe
assign(paste("intercepts_boot", glue("{param}"), sep =  "_"), intercepts_boot_df)
# slopes --> tidy dataframe
# To calculate an uncertainty on the correction, a vector of all 1001 slopes split out by the bootstrapping procedure is saved into its own file.
slopes_nf_boot_df <- data.frame(matrix(unlist(slopes_nf_boot), nrow = 1001, byrow = FALSE)) %>%
rename(A1 = X1, A = X2, `1` = X3, term1 = X4, term2 = X5, A2 = X6, `2`= X7, term0 = X8, B2 = X9, B = X10, B1 = X11) %>%
tibble() %>%
select("A", "A1", "A2", "B", "B1", "B2", "1", "2", "term0", "term1", "term2")
#Save results to named dataframe
assign(paste("slopes_nf_boot", glue("{param}"), sep =  "_"), slopes_nf_boot_df)
xlsx::write.xlsx(as.data.frame(results_nf_boot_esr), file="Regression Results_Final.xlsx", sheetName="results_nf_boot_esr", row.names=FALSE, append = TRUE)
xlsx::write.xlsx(as.data.frame(intercepts_boot_esr), file="Regression Results_Final.xlsx", sheetName="intercepts_boot_esr", row.names=FALSE, append = TRUE)
xlsx::write.xlsx(as.data.frame(slopes_nf_boot_esr), file="Regression Results_Final.xlsx", sheetName="slopes_nf_boot_esr", row.names=FALSE, append = TRUE)
param <- "ft"
results_taylor <- pmap(list(sample_df[[3]],
glue("{param}")),
taylor.uncertainty)
results_taylor_df <- data.frame(matrix(unlist(results_taylor), nrow = 11, byrow = TRUE)) %>%
rename(slope = X1, sigma.slope = X2, plot.slope = X3) %>%
bind_cols(sample_df[,2], sample_df[,1]) %>%
relocate(grouping, name, .before = slope) %>%
tibble() %>%
mutate(grouping = factor(grouping, levels = c("A", "A1", "A2", "B", "B1", "B2", "1", "2", "term0", "term1", "term2"))) %>%
arrange(grouping)
#Save results to named dataframe
assign(paste("results_taylor", glue("{param}"), sep =  "_"), results_taylor_df)
param <- "volume"
results_taylor <- pmap(list(sample_df[[3]],
glue("{param}")),
taylor.uncertainty)
results_taylor_df <- data.frame(matrix(unlist(results_taylor), nrow = 11, byrow = TRUE)) %>%
rename(slope = X1, sigma.slope = X2, plot.slope = X3) %>%
bind_cols(sample_df[,2], sample_df[,1]) %>%
relocate(grouping, name, .before = slope) %>%
tibble() %>%
mutate(grouping = factor(grouping, levels = c("A", "A1", "A2", "B", "B1", "B2", "1", "2", "term0", "term1", "term2"))) %>%
arrange(grouping)
#Save results to named dataframe
assign(paste("results_taylor", glue("{param}"), sep =  "_"), results_taylor_df)
param <- "esr"
results_taylor <- pmap(list(sample_df[[3]],
glue("{param}")),
taylor.uncertainty)
results_taylor_df <- data.frame(matrix(unlist(results_taylor), nrow = 11, byrow = TRUE)) %>%
rename(slope = X1, sigma.slope = X2, plot.slope = X3) %>%
bind_cols(sample_df[,2], sample_df[,1]) %>%
relocate(grouping, name, .before = slope) %>%
tibble() %>%
mutate(grouping = factor(grouping, levels = c("A", "A1", "A2", "B", "B1", "B2", "1", "2", "term0", "term1", "term2"))) %>%
arrange(grouping)
#Save results to named dataframe
assign(paste("results_taylor", glue("{param}"), sep =  "_"), results_taylor_df)
filename <- "Regression Results_Final.xlsx"
#glue("{filename}")
###### Taylor results, intercept fixed at zero
xlsx::write.xlsx(as.data.frame(results_taylor_ft), file= glue("{filename}"), sheetName="results_taylor_ft", row.names=FALSE, append = TRUE)
xlsx::write.xlsx(as.data.frame(results_taylor_volume), file = glue("{filename}"), sheetName="results_taylor_volume", row.names=FALSE, append = TRUE)
xlsx::write.xlsx(as.data.frame(results_taylor_esr), file = glue("{filename}"), sheetName="results_taylor_esr", row.names=FALSE, append = TRUE)
param <- "ft"
results_nf_taylor <- pmap(list(sample_df[[3]],
glue("{param}")),
taylor.uncertainty.not.fixed)
results_nf_taylor_df <- data.frame(matrix(unlist(results_nf_taylor), nrow = 11, byrow = TRUE)) %>%
rename(slope = X1, sigma.slope = X2, intercept = X3, sigma.intercept =X4, plot.slope = X5) %>%
bind_cols(sample_df[,2], sample_df[,1]) %>%
relocate(grouping, name, .before = slope) %>%
tibble() %>%
mutate(grouping = factor(grouping, levels = c("A", "A1", "A2", "B", "B1", "B2", "1", "2", "term0", "term1", "term2"))) %>%
arrange(grouping)
#Save results to named dataframe
assign(paste("results_nf_taylor", glue("{param}"), sep =  "_"), results_nf_taylor_df)
param <- "volume"
results_nf_taylor <- pmap(list(sample_df[[3]],
glue("{param}")),
taylor.uncertainty.not.fixed)
results_nf_taylor_df <- data.frame(matrix(unlist(results_nf_taylor), nrow = 11, byrow = TRUE)) %>%
rename(slope = X1, sigma.slope = X2, intercept = X3, sigma.intercept =X4, plot.slope = X5) %>%
bind_cols(sample_df[,2], sample_df[,1]) %>%
relocate(grouping, name, .before = slope) %>%
tibble() %>%
mutate(grouping = factor(grouping, levels = c("A", "A1", "A2", "B", "B1", "B2", "1", "2", "term0", "term1", "term2"))) %>%
arrange(grouping)
#Save results to named dataframe
assign(paste("results_nf_taylor", glue("{param}"), sep =  "_"), results_nf_taylor_df)
param <- "esr"
results_nf_taylor <- pmap(list(sample_df[[3]],
glue("{param}")),
taylor.uncertainty.not.fixed)
results_nf_taylor_df <- data.frame(matrix(unlist(results_nf_taylor), nrow = 11, byrow = TRUE)) %>%
rename(slope = X1, sigma.slope = X2, intercept = X3, sigma.intercept =X4, plot.slope = X5) %>%
bind_cols(sample_df[,2], sample_df[,1]) %>%
relocate(grouping, name, .before = slope) %>%
tibble() %>%
mutate(grouping = factor(grouping, levels = c("A", "A1", "A2", "B", "B1", "B2", "1", "2", "term0", "term1", "term2"))) %>%
arrange(grouping)
#Save results to named dataframe
assign(paste("results_nf_taylor", glue("{param}"), sep =  "_"), results_nf_taylor_df)
filename <- "Regression Results_Final.xlsx"
#glue("{filename}")
###### Taylor results,intercept not fixed at zero
xlsx::write.xlsx(as.data.frame(results_nf_taylor_ft), file =  glue("{filename}"), sheetName="results_nf_taylor_ft", row.names=FALSE, append = TRUE)
xlsx::write.xlsx(as.data.frame(results_nf_taylor_volume), file =  glue("{filename}"), sheetName="results_nf_taylor_volume", row.names=FALSE, append = TRUE)
xlsx::write.xlsx(as.data.frame(results_nf_taylor_esr), file = glue("{filename}"), sheetName="results_nf_taylor_esr", row.names=FALSE, append = TRUE)
source("function_error_propagation.R")
#source("function_bootstrapped_slopes.R")
#source("function_linreg_slope_uncertainty.R")
source("function_model_diagnostics.R")
#source("function_ttest_compare.R")
source("function_bootstrap_linreg_nested.R")
source("function_taylor_uncertainties_nested.R")
source("function_taylor_uncertainties_nested_notfixed.R")
source("function_bootstrap_linreg_nested_notfixed.R")
source("./Functions/function_error_propagation.R")
source("./Functions/function_error_propagation.R")
#source("function_bootstrapped_slopes.R")
#source("function_linreg_slope_uncertainty.R")
source("./Functions/function_model_diagnostics.R")
#source("function_ttest_compare.R")
source("./Functions/function_bootstrap_linreg_nested.R")
source("./Functions/function_taylor_uncertainties_nested.R")
source("./Functions/function_taylor_uncertainties_nested_notfixed.R")
source("./Functions/function_bootstrap_linreg_nested_notfixed.R")
