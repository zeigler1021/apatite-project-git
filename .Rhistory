hist(common_apatite$db.v, add = TRUE)
hist(boots_3d.df$V45, col = "red")
hist(common_apatite$db.v)
hist(slope)
lm(s.v ~ 0 + db.v, common_apatite)
abline(1.152)
vline(1.152, col = "blue", add= TRUE)
abline(v=1.152, col = "blue", add= TRUE)
boots_2d.t <- t(boots_2d.df)
boots_2d.t <- t(boots_2d.df)
View(boots_2d.t)
colMeans(boots_2d.t)
boots_3d.t <- t(boots_3d.df)
boots_2d.t <- t(boots_2d.df)
#bootstrap.test <- function(df) {
twoD <- common_apatite$s.v
threeD <- common_apatite$db.v
#Bootstrapping 2d and 3d values of my parameter
boots_2d <- lapply(1:261, function(i) sample(twoD, replace=TRUE))
boots_3d <- lapply(1:261, function(i) sample(threeD, replace=TRUE))
#Get data into a dataframe
boots_2d.df <- as.data.frame(do.call(cbind, boots_2d))
boots_3d.df <- as.data.frame(do.call(cbind, boots_3d))
boots_2d.t <- t(boots_2d.df)
t2d <- colMeans(boots_2d.t)
boots_3d.t <- t(boots_3d.df)
t3d <- colMeans(boots_3d.t)
lm(t2d  ~ 0)
lm(t2d ~ 0 + t3d)
#bootstrap.test <- function(df) {
twoD <- common_apatite$s.v
threeD <- common_apatite$db.v
#Bootstrapping 2d and 3d values of my parameter
boots_2d <- lapply(1:261, function(i) sample(twoD, replace=TRUE))
boots_3d <- lapply(1:261, function(i) sample(threeD, replace=TRUE))
#Get data into a dataframe
boots_2d.df <- as.data.frame(do.call(cbind, boots_2d))
boots_3d.df <- as.data.frame(do.call(cbind, boots_3d))
boots_2d.t <- t(boots_2d.df)
t2d <- colMeans(boots_2d.t)
boots_3d.t <- t(boots_3d.df)
t3d <- colMeans(boots_3d.t)
lm(t2d ~ 0 + t3d)
#bootstrap.test <- function(df) {
twoD <- common_apatite$s.v
threeD <- common_apatite$db.v
#Bootstrapping 2d and 3d values of my parameter
boots_2d <- lapply(1:261, function(i) sample(twoD, replace=TRUE))
boots_3d <- lapply(1:261, function(i) sample(threeD, replace=TRUE))
#Get data into a dataframe
boots_2d.df <- as.data.frame(do.call(cbind, boots_2d))
boots_3d.df <- as.data.frame(do.call(cbind, boots_3d))
View(boots_3d.df)
rowmean2d <- rowMeans(boots_2d.df)
rowmean3d <- rowMeans(boots_3d.df)
#initalize vector to store slopes and std errors
slope <- list()
std_err <- list()
lm(rowmean2d ~ 0 + rowmean3d)
summaryr(lm(rowmean2d ~ 0 + rowmean3d))
summary(lm(rowmean2d ~ 0 + rowmean3d))
#use the 261 samples inside the linear regression and produce a list of slopes of length 261
for (i in 1:261) {
linreg <- summary(lm(boots_2d.df[,i] ~ 0 + boots_3d.df[,i]))
slope[i] <- linreg$coefficients[1]
std_err[i] <- linreg$sigma
}
View(slope)
#use the 261 samples inside the linear regression and produce a list of slopes of length 261
for (i in 1:261) {
linreg <- summary(lm(boots_2d.df[i] ~ 0 + boots_3d.df[i]))
slope[i] <- linreg$coefficients[1]
std_err[i] <- linreg$sigma
}
#use the 261 samples inside the linear regression and produce a list of slopes of length 261
for (i in 1:261) {
linreg <- summary(lm(boots_2d.df[i,] ~ 0 + boots_3d.df[i,]))
slope[i] <- linreg$coefficients[1]
std_err[i] <- linreg$sigma
}
#bootstrap.test <- function(df) {
twoD <- common_apatite$s.v
threeD <- common_apatite$db.v
#Bootstrapping 2d and 3d values of my parameter
boots_2d <- lapply(1:261, function(i) sample(twoD, replace=TRUE))
boots_3d <- lapply(1:261, function(i) sample(threeD, replace=TRUE))
#Get data into a dataframe
boots_2d.df <- as.data.frame(do.call(cbind, boots_2d))
boots_3d.df <- as.data.frame(do.call(cbind, boots_3d))
rowmean2d <- rowMeans(boots_2d.df)
rowmean3d <- rowMeans(boots_3d.df)
#initalize vector to store slopes and std errors
slope <- list()
std_err <- list()
#use the 261 samples inside the linear regression and produce a list of slopes of length 261
for (i in 1:261) {
linreg <- summary(lm(boots_2d.df[i,] ~ 0 + boots_3d.df[i,]))
slope[i] <- linreg$coefficients[1]
std_err[i] <- linreg$sigma
}
str(boots_2d.df)
#bootstrap.test <- function(df) {
twoD <- common_apatite$s.v
threeD <- common_apatite$db.v
#Bootstrapping 2d and 3d values of my parameter
boots_2d <- lapply(1:261, function(i) sample(twoD, replace=TRUE))
boots_3d <- lapply(1:261, function(i) sample(threeD, replace=TRUE))
#Get data into a dataframe
boots_2d.df <- as.data.frame(do.call(cbind, boots_2d))
boots_3d.df <- as.data.frame(do.call(cbind, boots_3d))
rowmean2d <- rowMeans(boots_2d.df)
rowmean3d <- rowMeans(boots_3d.df)
#initalize vector to store slopes and std errors
slope <- list()
std_err <- list()
#use the 261 samples inside the linear regression and produce a list of slopes of length 261
for (i in 1:261) {
linreg <- summary(lm(boots_2d.df[,i] ~ 0 + boots_3d.df[,i]))
slope[i] <- linreg$coefficients[1]
std_err[i] <- linreg$sigma
}
View(slope)
lm(boots_2d.df$V1 ~ 0 + boots_3d.df$V1)
mean(boots_2d.df$V1)
mean(common_apatite$s.v)
mean(boots_3d.df$V1)
mean(common_apatite$db.v)
lm(boots_2d.df$V100 ~ 0 + boots_3d.df$V100)
# Chunk 1: setup
library(MASS)
library(latex2exp)
library(readxl)
library(ggplot2)
library(tidyverse)
library(tidyr)
library(scales)
library(dplyr)
library(readr)
library(xlsx)
library(performance) #check model
library(MASS)
library(plotly)
library(RColorBrewer)
library(ggsci)
library(patchwork)
library(viridis)
library(glue)
library(tinytex)
library(colorspace)
#library(datapaste)
library(ggthemes)
library(jcolors)
library(knitr)
par(mfrow=c(1, 1)) #how to arrange plots, 1 per row, 1 per column
#Theme options
theme_set(theme_light())
theme_update(plot.title = element_text(hjust = 0.5)) #adjusts theme so that all titles are centered
theme_update(plot.subtitle= element_text(hjust = 0.5)) #adjusts subtitle so they are all centered
options(scipen = 999) #prints numbers instead of scientific notation
# Chunk 2
apatite <- read_excel("./Data Comps_v7.xlsx", sheet="Data Comps")
as_tibble(apatite)
apatite <- apatite %>%
filter(!is.na(apatite$empty)) #this gets rid of data points that are missing information
# Chunk 3
apatite$size.bin <- factor(apatite$size.bin, levels = c("40-50", "51-60", "61-70", "71-80", "81-90", "91-100", "101-110", "111-120", "121-130", "131-140", "141-150", "151-160", "161-170"))
apatite$s.gem <- factor(apatite$s.gem, levels = c("A1", "A2", "A3", "B1", "B2", "B3", "C1", "C2", "C3"))
apatite$ri <- factor(df7.rm$ri, levels = c("1", "2", "3"))
apatite$size.name <- factor(apatite$size.name, levels=c("Small & Rare","Small & Common","Typical & Common", "Large & Common", "Large & Rare"))
apatite$gem.cat <- factor(apatite$gem.cat, levels = c("Best.GEM", "Average.GEM", "Worst.GEM"))
apatite$np <- factor(apatite$np, levels= c("0", "1", "2"))
# Chunk 4
quad <- read_excel("./Linear Reg Results.xlsx", sheet="comp")
# Chunk 5
#Grains Removed
common_apatite <- apatite %>%
filter(!size.name == "Large & Rare", !size.name == "Small & Rare")
# Chunk 6
#Dataframe by Roughness Index
ri1 <- common_apatite %>% filter(ri=="1")
ri2 <- common_apatite %>% filter(ri=="2")
ri3 <- common_apatite %>% filter(ri=="3")
#Dataframe by Geometric Classification
gca <- common_apatite %>% filter(gc=="A")
gcb <- common_apatite %>% filter(gc=="B")
gcc <- common_apatite %>% filter(gc=="C")
ab <- common_apatite %>% filter(gc == "A" | gc == "B") %>% mutate(s.gem= "AB")
#Create Dataframes split by both geometry and roughness
a1 <- common_apatite %>% filter(s.gem == "A1")
a2 <- common_apatite %>% filter(s.gem == "A2")
a3 <- common_apatite %>% filter(s.gem == "A3")
b1 <- common_apatite %>% filter(s.gem == "B1")
b2 <- common_apatite %>% filter(s.gem == "B2")
b3 <- common_apatite %>% filter(s.gem == "B3")
c1 <- common_apatite %>% filter(s.gem == "C1")
c2 <- common_apatite %>% filter(s.gem == "C2")
c3 <- common_apatite %>% filter(s.gem == "C3")
#Make dataframes based on terminations
term0 <- common_apatite %>% filter(np == "0")
term1 <- common_apatite %>% filter(np == "1")
term2 <- common_apatite %>% filter(np =="2")
# Chunk 7
source("function_error_propagation.R")
source("function_bootstrapped_slopes.R")
source("function_linreg_slope_uncertainty.R")
source("function_model_diagnostics.R")
# Chunk 8
source("function_error_lines.R")
vol_df <- common_apatite %>% select(sample, s.v, db.v)
View(vol_df)
vol_boot <- bootstraps(vol_df,
times = 1e3,
apparent = TRUE)
install.packages("tidymodels")
library(tidymodels)
install.packages("tidymodels")
library(tidymodels)
vol_df <- common_apatite %>% select(sample, s.v, db.v)
# Set set.seed a starting number to generate a sequence of random numbers so that we can get reproducible results
set.seed(123)
vol_boot <- bootstraps(vol_df,
times = 1e3,
apparent = TRUE)
View(vol_boot)
vol_models <- vol_boot %>%
mutate(model = map(splits, ~lm(s.v ~ 0 + db.v,
data = .) ),
coef_inf = map(model, tidy))
View(vol_models)
vol_coefs <- vol_models %>%
unnest(coef_inf)
View(vol_coefs)
View(vol_coefs[[1]][[1]])
View(vol_boot[[1]][[2]])
View(vol_models[[4]][[1]])
int_pctl(vol_models,
coef_inf)
View(vol_coefs)
sd(vol_coefs$estimate)
mean(vol_coefs$estimate)
View(vol_df)
vol_df[,3]
bootstrap.slope <- function(df, param) {
if (param == "ft") {
sample_df <- df %>% select(sample, s.ft,  db.ft)
}
if (param == "volume") {
sample_df <- df %>% select(sample, s.v,  db.v)
}
# Set set.seed a starting number to generate a sequence of random numbers so that we can get reproducible results
set.seed(123)
#Perform bootstrap
sample_boot <- bootstraps(sample_df,
times = 1e3,
apparent = TRUE)
#Run linear regression on each bootstrap
sample_models <- sample_boot %>%
mutate(model = map(splits, ~ lm(sample_df[,2] ~ 0 + sample_df[,3],
data = .) ),
coef_inf = map(model, tidy))
#Get coefficients
sample_coefs <- sample_models %>%
unnest(coef_inf)
#Get confidence interval
percentile_intervals <- int_pctl(sample_models,
coef_inf)
#Store results
results <<- as.data.frame(cbind(percentile_intervals$.estimate, sd(sample_coefs$estimate)))
print(results)
}
bootstrap.slope(common_apatite,  "ft")
sample_df <- common_apatite %>% select(sample, s.ft,  db.ft) %>% rename(twoD = s.ft,  threeD = db.ft)
View(sample_df)
rm(sample_df)
bootstrap.slope <- function(df, param) {
if (param == "ft") {
sample_df <- df %>% select(sample, s.ft,  db.ft) %>% rename(twoD = s.ft,  threeD = db.ft)
}
if (param == "volume") {
sample_df <- df %>% select(sample, s.v,  db.v) %>% rename(twoD = s.v,  threeD = db.v)
}
# Set set.seed a starting number to generate a sequence of random numbers so that we can get reproducible results
set.seed(123)
#Perform bootstrap
sample_boot <- bootstraps(sample_df,
times = 1e3,
apparent = TRUE)
#Run linear regression on each bootstrap
sample_models <- sample_boot %>%
mutate(model = map(splits, ~ lm(twoD ~ 0 + threeD,
data = .) ),
coef_inf = map(model, tidy))
#Get coefficients
sample_coefs <- sample_models %>%
unnest(coef_inf)
#Get confidence interval
percentile_intervals <- int_pctl(sample_models,
coef_inf)
#Store results
results <<- as.data.frame(cbind(percentile_intervals$.estimate, sd(sample_coefs$estimate)))
print(results)
}
bootstrap.slope(common_apatite,  "ft")
bootstrap.slope <- function(df, param) {
if (param == "ft") {
sample_df <- df %>% select(sample, s.ft,  db.ft) %>% rename(twoD = s.ft,  threeD = db.ft)
}
if (param == "volume") {
sample_df <- df %>% select(sample, s.v,  db.v) %>% rename(twoD = s.v,  threeD = db.v)
}
# Set set.seed a starting number to generate a sequence of random numbers so that we can get reproducible results
set.seed(123)
#Perform bootstrap
sample_boot <- bootstraps(sample_df,
times = 1e3,
apparent = TRUE)
#Run linear regression on each bootstrap
sample_models <- sample_boot %>%
mutate(model = map(splits, ~ lm(twoD ~ 0 + threeD,
data = .) ),
coef_inf = map(model, tidy))
#Get coefficients
sample_coefs <- sample_models %>%
unnest(coef_inf)
#Get confidence interval
percentile_intervals <- int_pctl(sample_models,
coef_inf)
#Store results
results <<- as.data.frame(cbind(percentile_intervals$.estimate, sd(sample_coefs$estimate))) %>%
rename(slope = V1, sd = V2)
print(results)
}
bootstrap.slope(common_apatite,  "ft")
bootstrap.slope(b3,  "volume")
rm(bootstrap.linreg)
bootstrap.linreg <- function(df, param) {
if (param == "ft") {
sample_df <- df %>% select(sample, s.ft,  db.ft) %>% rename(twoD = s.ft,  threeD = db.ft)
}
if (param == "volume") {
sample_df <- df %>% select(sample, s.v,  db.v) %>% rename(twoD = s.v,  threeD = db.v)
}
# Set set.seed a starting number to generate a sequence of random numbers so that we can get reproducible results
set.seed(123)
#Perform bootstrap
sample_boot <- bootstraps(sample_df,
times = 1e3,
apparent = TRUE)
#Run linear regression on each bootstrap
sample_models <- sample_boot %>%
mutate(model = map(splits, ~ lm(twoD ~ 0 + threeD,
data = .) ),
coef_inf = map(model, tidy))
#Get coefficients
sample_coefs <- sample_models %>%
unnest(coef_inf)
#Get confidence interval
percentile_intervals <- int_pctl(sample_models,
coef_inf)
#Store results
results <<- as.data.frame(cbind(percentile_intervals$.estimate, sd(sample_coefs$estimate))) %>%
rename(slope = V1, sd = V2)
print(results)
}
# Chunk 1: setup
library(MASS)
library(latex2exp)
library(readxl)
library(ggplot2)
library(tidyverse)
library(tidyr)
library(scales)
library(dplyr)
library(readr)
library(xlsx)
library(performance) #check model
library(MASS)
library(plotly)
library(RColorBrewer)
library(ggsci)
library(patchwork)
library(viridis)
library(glue)
library(tinytex)
library(colorspace)
#library(datapaste)
library(ggthemes)
library(jcolors)
library(knitr)
library(tidymodels)
par(mfrow=c(1, 1)) #how to arrange plots, 1 per row, 1 per column
#Theme options
theme_set(theme_light())
theme_update(plot.title = element_text(hjust = 0.5)) #adjusts theme so that all titles are centered
theme_update(plot.subtitle= element_text(hjust = 0.5)) #adjusts subtitle so they are all centered
options(scipen = 999) #prints numbers instead of scientific notation
# Chunk 2
apatite <- read_excel("./Data Comps_v7.xlsx", sheet="Data Comps")
as_tibble(apatite)
apatite <- apatite %>%
filter(!is.na(apatite$empty)) #this gets rid of data points that are missing information
# Chunk 3
apatite$size.bin <- factor(apatite$size.bin, levels = c("40-50", "51-60", "61-70", "71-80", "81-90", "91-100", "101-110", "111-120", "121-130", "131-140", "141-150", "151-160", "161-170"))
apatite$s.gem <- factor(apatite$s.gem, levels = c("A1", "A2", "A3", "B1", "B2", "B3", "C1", "C2", "C3"))
apatite$ri <- factor(df7.rm$ri, levels = c("1", "2", "3"))
apatite$size.name <- factor(apatite$size.name, levels=c("Small & Rare","Small & Common","Typical & Common", "Large & Common", "Large & Rare"))
apatite$gem.cat <- factor(apatite$gem.cat, levels = c("Best.GEM", "Average.GEM", "Worst.GEM"))
apatite$np <- factor(apatite$np, levels= c("0", "1", "2"))
# Chunk 4
quad <- read_excel("./Linear Reg Results.xlsx", sheet="comp")
# Chunk 5
#Grains Removed
common_apatite <- apatite %>%
filter(!size.name == "Large & Rare", !size.name == "Small & Rare")
# Chunk 6
#Dataframe by Roughness Index
ri1 <- common_apatite %>% filter(ri=="1")
ri2 <- common_apatite %>% filter(ri=="2")
ri3 <- common_apatite %>% filter(ri=="3")
#Dataframe by Geometric Classification
gca <- common_apatite %>% filter(gc=="A")
gcb <- common_apatite %>% filter(gc=="B")
gcc <- common_apatite %>% filter(gc=="C")
ab <- common_apatite %>% filter(gc == "A" | gc == "B") %>% mutate(s.gem= "AB")
#Create Dataframes split by both geometry and roughness
a1 <- common_apatite %>% filter(s.gem == "A1")
a2 <- common_apatite %>% filter(s.gem == "A2")
a3 <- common_apatite %>% filter(s.gem == "A3")
b1 <- common_apatite %>% filter(s.gem == "B1")
b2 <- common_apatite %>% filter(s.gem == "B2")
b3 <- common_apatite %>% filter(s.gem == "B3")
c1 <- common_apatite %>% filter(s.gem == "C1")
c2 <- common_apatite %>% filter(s.gem == "C2")
c3 <- common_apatite %>% filter(s.gem == "C3")
#Make dataframes based on terminations
term0 <- common_apatite %>% filter(np == "0")
term1 <- common_apatite %>% filter(np == "1")
term2 <- common_apatite %>% filter(np =="2")
# Chunk 7
source("function_error_propagation.R")
source("function_bootstrapped_slopes.R")
source("function_linreg_slope_uncertainty.R")
source("function_model_diagnostics.R")
# Chunk 8
source("function_error_lines.R")
View(bootstrap.linreg)
bootstrap.linreg(a,  "ft")
bootstrap.linreg(gca,  "ft")
View(results)
bootstrap.linreg(gcb,  "ft")
bootstrap.linreg(gcc,  "ft")
bootstrap.linreg <- function(df, param) {
if (param == "ft") {
sample_df <- df %>% select(sample, s.ft,  db.ft) %>% rename(twoD = s.ft,  threeD = db.ft)
}
if (param == "volume") {
sample_df <- df %>% select(sample, s.v,  db.v) %>% rename(twoD = s.v,  threeD = db.v)
}
# Set set.seed a starting number to generate a sequence of random numbers so that we can get reproducible results
set.seed(123)
#Perform bootstrap
sample_boot <- bootstraps(sample_df,
times = 1e3,
apparent = TRUE)
#Run linear regression on each bootstrap
sample_models <- sample_boot %>%
mutate(model = map(splits, ~ lm(twoD ~ 0 + threeD,
data = .) ),
coef_inf = map(model, tidy))
#Get coefficients
sample_coefs <<- sample_models %>%
unnest(coef_inf)
#Get confidence interval
percentile_intervals <- int_pctl(sample_models,
coef_inf)
#Store results
results <<- as.data.frame(cbind(percentile_intervals$.estimate, sd(sample_coefs$estimate))) %>%
rename(slope = V1, sd = V2)
print(results)
}
bootstrap.linreg(gcc,  "ft")
View(sample_coefs)
bootstrap.linreg <- function(df, param) {
if (param == "ft") {
sample_df <- df %>% select(sample, s.ft,  db.ft) %>% rename(twoD = s.ft,  threeD = db.ft)
}
if (param == "volume") {
sample_df <- df %>% select(sample, s.v,  db.v) %>% rename(twoD = s.v,  threeD = db.v)
}
# Set set.seed a starting number to generate a sequence of random numbers so that we can get reproducible results
set.seed(123)
#Perform bootstrap
sample_boot <- bootstraps(sample_df,
times = 1e3,
apparent = TRUE)
#Run linear regression on each bootstrap
sample_models <- sample_boot %>%
mutate(model = map(splits, ~ lm(twoD ~ 0 + threeD,
data = .) ),
coef_inf = map(model, tidy))
#Get coefficients
sample_coefs <- sample_models %>%
unnest(coef_inf)
#Get confidence interval
percentile_intervals <- int_pctl(sample_models,
coef_inf)
#Store results
results <<- as.data.frame(cbind(percentile_intervals$.estimate, sd(sample_coefs$estimate),mean(sample_coefs$std.error))) %>%
rename(slope = V1, sd = V2, std.error = V3)
print(results)
}
bootstrap.linreg(gcc,  "ft")
